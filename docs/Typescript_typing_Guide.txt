Typescript typing Guide
1. Introducci√≥n
Objetivo del Documento
Explicar la importancia del tipado en TypeScript y establecer lineamientos
claros sobre el uso de interface, type, any, unknown y gen√©ricos, adem√°s de
los tipos avanzados y enum, dentro del equipo de desarrollo en LearUp.

Beneficios del Tipado
Mejora de la seguridad del c√≥digo.
Detecci√≥n temprana de errores.
Mejor documentaci√≥n y autocompletado en IDEs.

2. Uso de Interfaces
Definici√≥n de Interfaces
Una interface se usa para definir la estructura de un objeto de manera clara y
extensible. Se recomienda para estructuras que puedan evolucionar con el
tiempo y ser extendidas.

Sintaxis B√°sica
interface User {
id: number;
name: string;
email: string;
}

Extensi√≥n de Interfaces
Permite heredar propiedades de otras interfaces, facilitando la reutilizaci√≥n del
c√≥digo.

Typescript typing Guide

1

interface Person {
id: number;
name: string;
}
interface Employee extends Person {
position: string;
}

Ejemplo Pr√°ctico
Caso de uso: Modelado de datos de usuario en una API.
function getUser(): User {
return { id: 1, name: "John Doe", email: "john@company.com" };
}

3. Uso de Types
Definici√≥n de Types
Un type permite definir valores basados en los tipos primitivos de TypeScript:

Tipos B√°sicos
// Primitive Types
type Text = string;
// Text strings
type Age = number;
// Numbers (integers or decimals)
type IsActive = boolean; // True or false values
type CreatedAt = Date; // Dates and times
type UniqueID = symbol; // Unique identifiers
type AnyValue = any; // Any type (avoid using it)
type UnknownValue = unknown; // Any type, but safer than 'any'
type Nothing = void; // Functions with no return value
type NeverHappens = never; // Value that never occurs

Typescript typing Guide

2

string / number / boolean: Datos b√°sicos como nombres, edades o
estados.
Date ‚Üí Fechas en APIs o registros.
symbol ‚Üí Identificadores √∫nicos en estructuras avanzadas.
void / never ‚Üí Definir funciones con retorno vac√≠o o errores.
any / unknown ‚Üí Casos donde el tipo es incierto (se recomienda unknown
sobre any).

Tipos de Uni√≥n e Intersecci√≥n
Uni√≥n (|): Permite m√∫ltiples tipos posibles.
Intersecci√≥n (&): Combina m√∫ltiples tipos en uno solo

üìå

//
Union: A value can be one type or another
type ID = string | number;
type Status = "active" | "inactive" | "pending";
let userId: ID = 123;
userId = "abc123"; //

‚úÖ Correct, as it can be a string or a number

let accountStatus: Status = "active";
accountStatus = "suspended"; //
Error: "suspended" is not a valid value

üìå

‚ùå

//
Intersection: Combines multiple types into one
type User = { id: number; name: string };
type Employee = User & { position: string; salary: number };
const employee: Employee = {
id: 1,
name: "Alice",
position: "Developer",
salary: 50000
};
//

‚ùå Error if a property is missing (e.g., position or salary)

Typescript typing Guide

3

Tipos Literales
Restringen un valor a un conjunto espec√≠fico.
type Role = "admin" | "user" | "guest"; // Can only be one of these values

Tipos de Funciones
Definen la firma de una funci√≥n, asegurando los tipos de sus par√°metros y
respuesta.
// Define a function type
type MathOperation = (a: number, b: number) => number;
// Functions that match the signature
const sum: MathOperation = (x, y) => x + y;
const multiply: MathOperation = (x, y) => x * y;

‚û°Ô∏è 8
‚û°Ô∏è 15

console.log(sum(5, 3));
//
console.log(multiply(5, 3)); //

4. Uso de Tipos Gen√©ricos
Definici√≥n de Tipos Gen√©ricos
Los tipos gen√©ricos permiten crear estructuras reutilizables que trabajan con
tipos din√°micos en lugar de un tipo fijo. Esto los hace flexibles y escalables.

Sintaxis basica de Gen√©ricos
function identity<T>(arg: T): T {
return arg;
}

‚û°Ô∏è 10 (type: number)
console.log(identity("Hola")); // ‚û°Ô∏è "Hola" (type: string)
console.log(identity(10));

T

//

es un par√°metro de tipo que representa un tipo din√°mico.

Typescript typing Guide

4

Se resuelve autom√°ticamente seg√∫n el valor pasado.

Uso de gen√©ricos en interfaces
En interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir
estructuras reutilizables sin perder el tipado fuerte.
interface ApiResponse<T> {
data: T | null;
status: number;
error?: string;
}
const userResponse: ApiResponse<{ id: number; name: string }> = { // 'T' i
n this case is an object with 'id' and 'name'

‚úÖ

data: { id: 1, name: "Alice" }, //
User data retrieved successfully
status: 200
//
Successful HTTP status code

‚úÖ

};

const errorResponse: ApiResponse<null> = { // 'T' in this case is null

‚ùå No data available
// ‚ùå Status code indicating 'Not Found'
error: "User not found" // ‚úÖ Error message
data: null,
status: 404,

};

//

Ejemplo Pr√°ctico
Caso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de
API.
//

üìå Generic interface for API responses

interface ApiResponse<T> {
data: T | null; // Holds the response data or null if there's an error
status: number;
error?: string;
}
//

üìå Generic function to fetch data from an API

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {

Typescript typing Guide

5

try {
const response = await fetch(url);
// Check if the response is not successful
if (!response.ok) {
return { data: null, status: response.status, error: response.statusTex
t };
}
// Parse and return the JSON response
const data: T = await response.json();
return { data, status: response.status };
} catch (error) {
// Handle network or unexpected errors
return { data: null, status: 500, error: (error as Error).message };
}
}

5. Tipos Especiales: any vs unknown
Diferencias entre any y unknown
any: Permite cualquier tipo sin restricciones, deshabilitando la seguridad de
tipos.
unknown: Acepta cualquier tipo, pero requiere validaci√≥n antes de su uso.

Cu√°ndo usar any
A pesar de que unknown es generalmente m√°s seguro, existen situaciones
espec√≠ficas donde any puede ser apropiado:
Migraciones graduales: Cuando se migra c√≥digo JavaScript a TypeScript
de forma incremental.
Integraciones con bibliotecas externas: Al trabajar con bibliotecas sin
definiciones de tipos.
Prototipos r√°pidos: En fases iniciales de desarrollo donde la prioridad es la
velocidad.

Typescript typing Guide

6

Datos con estructura impredecible: Al recibir datos cuya estructura puede
variar significativamente.
let data: any;
data = "Texto";
data = 42;
let result: string = data; //
es en runtime

‚úÖ Se permite sin validaci√≥n, puede causar error

Ejemplo con unknown (Recomendado)
El tipo unknown debe ser la opci√≥n predeterminada cuando se necesita
flexibilidad de tipos:
let value: unknown;
value = "Texto";
value = 42;
if (typeof value === "string") {
let str: string = value; //
Solo se permite tras validaci√≥n
}

‚úÖ

6. Tipos Avanzados
Tipos Condicionales
Permiten evaluar un tipo en tiempo de compilaci√≥n.
type IsString<T> = T extends string ? "Yes" : "No";
type Result = IsString<number>; // "No"

Inferencia de Tipos
function getProperty<T, K extends keyof T>(obj: T, key: K) {
return obj[key];
}

Typescript typing Guide

7

Tipos Utilitarios Comunes en TypeScript: Record Omit y
Exclude
Record<K, V> : Permite definir un objeto donde las claves (K) tienen un tipo

espec√≠fico y los valores (V) siguen una estructura determinada.
type Users = Record<string, { id: number; name: string }>;
const users: Users = {
user1: { id: 1, name: "Alice" },
user2: { id: 2, name: "Bob" }
};
Omit<T, K> :

Elimina propiedades espec√≠ficas de un tipo.

type User = { id: number; name: string; email: string };
type UserWithoutEmail = Omit<User, "email">;
Exclude<T, U> : Elimina tipos de una uni√≥n.

type Status = "active" | "inactive" | "banned";
type ActiveStatus = Exclude<Status, "banned">;

Tipos Utilitarios Mapeados
Se usan para transformar las propiedades de un tipo existente.
// Ejemplo con geneticos
type ReadonlyWrapper<T> = {
readonly [K in keyof T]: T[K];
};
// Ejemplo con type
type User = {
id: number;
name: string;
};
type ReadonlyUser = ReadonlyWrapper<User>;
// Equivalente a:

Typescript typing Guide

8

// type ReadonlyUser = { readonly id: number; readonly name: string; }
const user: ReadonlyUser = { id: 1, name: "Juan" };
user.name = "Pedro"; //
donly

‚ùå Error: No se puede modificar una propiedad rea

Readonly, Partial, Required y Pick
Estos tipos utilitarios permiten manipular las propiedades de un objeto:
type User = {
id: number;
name: string;
email?: string;
};
Readonly<T> : Convierte todas las propiedades en solo lectura.

type ReadonlyUser = Readonly<User>;
Partial<T> : Hace que todas las propiedades sean opcionales.

type PartialUser = Partial<User>;
Required<T> : Hace que todas las propiedades sean requeridas.

type RequiredUser = Required<User>;
Pick<T, K> : Selecciona propiedades espec√≠ficas de un tipo.

type UserIdAndName = Pick<User, "id" | "name">;
Para ampliar la informacion sobre otros utility types pueden visitar la
documentacion oficial https://www.typescriptlang.org/docs/handbook/utilitytypes.html

Typescript typing Guide

9

8. Uso de Enum en TypeScript
Definici√≥n de Enum
Un enum es un tipo especial en TypeScript que permite definir un conjunto de
constantes con nombre.

Tipos de Enum
Enum Num√©rico
Por defecto, los enums asignan valores num√©ricos comenzando desde 0:
enum Direction {
Up, // 0
Down, // 1
Left, // 2
Right // 3
}
console.log(Direction.Up); // 0
console.log(Direction[0]); // "Up" (reverse mapping)

Enum con Valores Inicializados
Se pueden asignar valores espec√≠ficos:
enum Direction {
Up = 1,
Down, // 2
Left, // 3
Right // 4
}

Enum de Cadenas
enum UserRole {
Admin = "ADMIN",
User = "USER",
Guest = "GUEST"

Typescript typing Guide

10

}
// No hay reverse mapping en enums de cadenas
console.log(UserRole.Admin); // "ADMIN"

Caracter√≠stica de Reverse Mapping
Los enums num√©ricos generan un mapa bidireccional (nombre a valor y valor a
nombre):
enum Direction {
Up = 1,
Down,
Left,
Right
}
console.log(Direction[2]); // "Down"
Esto aumenta el tama√±o del c√≥digo generado, ya que se crea un objeto m√°s
complejo.

Enums Const
Los const enum se eliminan completamente durante la compilaci√≥n,
reemplazando sus referencias con valores literales, lo que resulta en un c√≥digo
m√°s eficiente:
const enum Direction {
Up = 1,
Down,
Left,
Right
}
const dir = Direction.Up; // Se compila a: const dir = 1;

Ejemplo Pr√°ctico

Typescript typing Guide

11

Caso de uso: Definir roles de usuario en una aplicaci√≥n.
function getPermissions(role: UserRole) {
if (role === UserRole.Admin) {
return "Full access";
}
return "Limited access";
}

9. Enum vs Tipos literales
Usar enum cuando:
Se requiere una representaci√≥n en tiempo de ejecuci√≥n
existe en JavaScript despu√©s de la compilaci√≥n, lo que permite
acceder a sus valores en tiempo de ejecuci√≥n.
enum

√ötil si necesitas valores asignados autom√°ticamente o bidireccionales
(clave-valor y valor-clave).
Los valores son usados en m√∫ltiples archivos o m√≥dulos
Si los valores deben ser reutilizables en varios lugares, los enum pueden
ser m√°s convenientes.
Trabajas con valores din√°micos
Si necesitas asignar valores personalizados, como cadenas o n√∫meros
espec√≠ficos.

Ejemplo de enum
enum UserRole {
Admin = "admin",
User = "user",
Guest = "guest"
}
function getPermissions(role: UserRole) {
if (role === UserRole.Admin) {
return "Acceso total";

Typescript typing Guide

12

}
return "Acceso limitado";
}
console.log(getPermissions(UserRole.Admin)); // "Acceso total"

Usar type con uniones literales cuando:
No se necesita una representaci√≥n en tiempo de ejecuci√≥n
desaparece despu√©s de la compilaci√≥n, mejorando el rendimiento
y reduciendo el tama√±o del c√≥digo.
type

Se busca mejor compatibilidad con inferencia de tipos
TypeScript puede inferir valores m√°s f√°cilmente con uniones literales.
Los valores no necesitan l√≥gica asociada
Si solo necesitas definir un conjunto de valores sin m√©todos
adicionales.

Ejemplo de type con uniones literales
type UserRole = "admin" | "user" | "guest";
function getPermissions(role: UserRole) {
if (role === "admin") {
return "Acceso total";
}
return "Acceso limitado";
}
console.log(getPermissions("admin")); // "Acceso total"

10. Recursos Adicionales
https://www.typescriptlang.org/docs/handbook/intro.html

Typescript typing Guide

13

https://docs.aws.amazon.com/prescriptive-guidance/latest/best-practicescdk-typescript-iac/typescript-best-practices.html
https://basarat.gitbook.io/typescript/type-system
Iv√°n Santander

Typescript typing Guide

14




Guia Escrita por Ivan Santander