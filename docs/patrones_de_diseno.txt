## Que es un patron de diseno ?

Es como una receta o un plan de accion para solucionar un problema, funcionan en diferentes ambientes tanto fron como backend

[**Se clasifican en 3 campos generales**](https://www.notion.so/Clasificacion-y-uso-5ca0d6225b6c4ecda13e5e5a263c19d9?pvs=21)

### **Patrones de Creación:**

1. **Singleton:** Garantiza una única instancia de una clase y proporciona un punto de acceso global a ella.
2. **Factory Method:** Define una interfaz para crear objetos en una superclase, delegando la creación de objetos a las subclases.
3. **Abstract Factory:** Proporciona una interfaz para crear familias de objetos relacionados sin especificar sus clases concretas.
4. **Builder:** Separar la construcción de un objeto complejo de su representación, permitiendo la creación de diferentes representaciones del mismo objeto.
5. **Prototype:** Utiliza un prototipo existente como base para crear nuevos objetos, permitiendo la copia de objetos complejos sin acoplar a sus clases concretas.

### **Patrones de Estructura:**

1. **Adapter:** Permite que interfaces incompatibles trabajen juntas, convirtiendo la interfaz de una clase en otra interfaz que el cliente espera.
2. **Bridge:** Separa una abstracción de su implementación, permitiendo que ambas puedan variar de forma independiente.
3. **Composite:** Compone objetos en estructuras de árbol para representar jerarquías parte-todo, permitiendo tratar a los objetos individuales y a las composiciones de manera uniforme.
4. **Decorator:** Agrega comportamiento adicional a un objeto de forma dinámica, proporcionando una alternativa flexible a la herencia para extender funcionalidades.
5. **Facade:** Proporciona una interfaz unificada para un conjunto de interfaces en un subsistema, simplificando el acceso y la utilización de dicho subsistema.
6. **Flyweight:** Minimiza el uso de memoria compartiendo lo máximo posible entre objetos similares, reduciendo la redundancia cuando se manejan grandes cantidades de objetos.
7. **Proxy:** Actúa como un intermediario para controlar el acceso a otro objeto, permitiendo agregar funcionalidades como lazy loading, control de acceso, entre otros.

### **Patrones de Comportamiento:**

1. **Chain of Responsibility:** Permite pasar solicitudes a través de una cadena de manejadores, cada uno de los cuales decide si manejar la solicitud o pasarla al siguiente en la cadena.
2. **Command:** Encapsula una solicitud como un objeto, permitiendo parametrizar clientes con diferentes solicitudes, encolar o registrar solicitudes, y soportar operaciones reversibles.
3. **Interpreter:** Define una representación gramatical para un lenguaje y proporciona un intérprete para evaluar sentencias en ese lenguaje.
4. **Iterator:** Proporciona una forma de acceder a elementos de una colección de manera secuencial sin exponer su representación interna.
5. **Mediator:** Define un objeto que encapsula cómo un conjunto de objetos interactúa, promoviendo el bajo acoplamiento al evitar que los objetos se comuniquen directamente entre sí.
6. **Memento:** Captura y externaliza el estado interno de un objeto, permitiendo restaurar el objeto a un estado anterior sin violar la encapsulación.
7. **Observer:** Define una dependencia uno a muchos entre objetos, de modo que cuando un objeto cambia su estado, todos los objetos dependientes son notificados y actualizados automáticamente.
8. **State:** Permite que un objeto altere su comportamiento cuando su estado interno cambia, creando una serie de clases para cada estado posible y evitando largas listas de condiciones.
9. **Strategy:** Define una familia de algoritmos, encapsula cada uno de ellos y los hace intercambiables, permitiendo que el algoritmo varíe independientemente de los clientes que lo utilizan.
10. **Template Method:** Define el esqueleto de un algoritmo en una operación, delegando algunos pasos a las subclases. Las subclases pueden redefinir ciertos pasos del algoritmo sin cambiar su estructura general.
11. **Visitor:** Permite agregar nuevas operaciones a objetos existentes sin modificar su estructura, separando el objeto de lo que se quiere hacer con él.

## Cuales son los 4 principios de la programacion orientada a objetos?

1. encapsulamiento: Cada objeto debe mantener en secreto sus detalles y valores internos y solo debe exporner las nterfaces necesarias para interactuar con el.
2. Abstraccion: Conocemos la forma de interactuar y que hace un objeto pero no conocemos sus comportamientos internos
3. Herencia: Se basa en la reutilizacion, atributos y metodos comunes pueden ser reutilzados, se pueden definir relaciones jeragicas entre clases.
4. Polimorfismo: Nos permite la posibilidad de procesar objetos de distintas maneras.

[Clasificacion y uso](https://www.notion.so/Clasificacion-y-uso-5ca0d6225b6c4ecda13e5e5a263c19d9?pvs=21)

# PdfViewer Component Documentation

A client-side React component that renders PDF documents with multiple interactive features including zoom, search, page navigation, and more.

## Component Overview

The PdfViewer is an organism-level component built with react-pdf-viewer that provides a complete PDF viewing experience. It integrates with multiple plugins to offer functionality such as zoom controls, page navigation, printing, downloading, full-screen mode, and text search.

## Props

The component accepts the following props:

- **`fileUrl`** (string, required): URL to the PDF file to be displayed.
- **`maxWidthViewer`** (number, optional): Maximum width of the PDF viewer in pixels. Default is 950px.

## Features

- **Zoom controls**: Zoom in, zoom out, and reset zoom level
- **Page navigation**: Navigate between pages with page input control
- **Document actions**: Download, print, and enter full-screen mode
- **Text search**: Search text within the PDF document (Ctrl+F shortcut supported)
- **Smooth scrolling**: Enhanced scroll experience

## Dependencies

### External Libraries

- `@react-pdf-viewer/core`: Core PDF viewer functionality
- `pdfjs-dist`: PDF.js distribution used for PDF rendering
- `Various @react-pdf-viewer plugins`: full-screen, page-navigation, print, search, zoom, and get-file

### Internal Components

- `EditDocumentMenu`: Provides the control menu with navigation, zoom, and action buttons

### Custom Hooks

- `usePdfPlugins`: Initializes and provides all the PDF viewer plugins

## Styling

The component uses:

- Tailwind CSS classes for layout and responsiveness
- Imported CSS styles from various @react-pdf-viewer plugins
- Dynamic styling through useMemo for the viewer width

## Performance Optimizations

- `React.memo` is used to prevent unnecessary re-renders
- `useMemo` is used to memoize the viewer style
- External worker is used for PDF processing to keep UI responsive

## Usage Example

Here's a basic example of how to use this component:

```jsx
import PdfViewer from '@/components/organisms/PdfViewer';

function DocumentPage() {
  const pdfUrl = 'https://example.com/sample.pdf';
  
  return (
    <div className="document-container">
      <PdfViewer fileUrl={pdfUrl} />
    </div>
  );
}
```

## Browser Compatibility

The component uses the PDF.js worker which needs to be loaded from a CDN. The component has a check for browser environment to ensure the worker is only loaded client-side:

```jsx
// Client-side only worker initialization
if (typeof window !== 'undefined') {
  GlobalWorkerOptions.workerSrc =
    'https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js';
}
```