Análisis y Recomendaciones para la Gestión de Permisos
Jerárquicos en un Sistema de Gestión Documental
1.​ Introducción:​

La gestión de permisos robusta y escalable en sistemas de gestión documental
es fundamental para garantizar la seguridad de los datos y el cumplimiento
normativo. La introducción de permisos jerárquicos añade una capa de
complejidad, requiriendo una consideración cuidadosa de la herencia y los
diferentes niveles de acceso. Una estructura de base de datos eficiente es
esencial para asegurar el rendimiento, la escalabilidad y la mantenibilidad de la
gestión de permisos y las funcionalidades de compartición. Esquemas mal
diseñados pueden conducir a consultas complejas, rendimiento lento y posibles
vulnerabilidades de seguridad. El presente informe tiene como objetivo analizar
críticamente la estructura de base de datos actual, evaluar su idoneidad para los
requisitos especificados y proporcionar una recomendación bien justificada
sobre el enfoque óptimo, incluyendo una guía práctica para su implementación.
2.​ Análisis Crítico de la Estructura Actual de la Base de Datos:​
El esquema actual de la base de datos consta de las tablas DocumentDMS,
FolderDMS, EffectivePermission, Share y AccessLevel, cuyas relaciones son
cruciales para comprender la gestión de permisos. Es fundamental entender las
columnas de cada tabla y las relaciones que existen entre ellas, como las claves
foráneas. La forma en que se relacionan los documentos y las carpetas, y si
existe una relación auto-referencial en FolderDMS para representar la jerarquía,
son aspectos importantes a considerar. También es necesario analizar cómo se
vinculan los permisos a los usuarios, documentos o carpetas y los niveles de
acceso, así como el papel de la tabla Share en la concesión de acceso a otros
usuarios. La presencia de la tabla EffectivePermission sugiere un cálculo previo o
materialización de los permisos, por lo que es necesario comprender cómo se
puebla y se mantiene esta tabla.​
Las estrategias para la organización de archivos y carpetas a nivel de sistema de
archivos enfatizan la importancia de las estructuras jerárquicas y las
convenciones de nomenclatura consistentes.1 Es probable que estas
consideraciones se reflejen en las tablas FolderDMS y DocumentDMS, aunque no
detallan directamente el aspecto de los permisos. Sistemas de gestión
documental eficaces deben ofrecer control de acceso y privilegios de edición 7, lo
que sugiere que el esquema actual probablemente tiene como objetivo soportar
estas funcionalidades. La tabla 1 presenta una posible estructura para el
esquema actual de la base de datos, aunque la estructura real puede variar.

Tabla

Columna

Tipo de
Datos

Clave
Primaria

DocumentD
MS

document_id

INTEGER

Sí

folder_id

INTEGER

name

VARCHAR

Nombre del
documento

...

...

Otros
atributos del
documento

folder_id

INTEGER

parent_folde
r_id

INTEGER

name

VARCHAR

Nombre de
la carpeta

...

...

Otros
atributos de
la carpeta

effective_per
mission_id

INTEGER

FolderDMS

EffectivePer
mission

Clave
Foránea

Identificador
único del
documento
Sí

Sí

Referencia a
la carpeta
que contiene
el
documento
en
FolderDMS

Identificador
único de la
carpeta
Sí (a sí
mismo)

Sí

Descripción

Referencia a
la carpeta
padre en
FolderDMS
(para la
jerarquía)

Identificador
único del
permiso

efectivo

Share

user_id

INTEGER

Referencia al
usuario

document_id

INTEGER

Sí

Referencia al
documento
en
DocumentD
MS

folder_id

INTEGER

Sí

Referencia a
la carpeta en
FolderDMS

access_level
_id

INTEGER

Sí

Referencia al
nivel de
acceso en
AccessLevel
(ej., lectura,
escritura)

...

...

share_id

INTEGER

document_id

INTEGER

Sí

Referencia al
documento
compartido
en
DocumentD
MS

folder_id

INTEGER

Sí

Referencia a
la carpeta
compartida
en

Otros
atributos del
permiso
efectivo
Sí

Identificador
único del
recurso
compartido

FolderDMS

AccessLevel

shared_with_
user_id

INTEGER

Referencia al
usuario con
el que se
comparte

access_level
_id

INTEGER

shared_by_u
ser_id

INTEGER

Referencia al
usuario que
compartió el
recurso

...

...

Otros
atributos del
recurso
compartido
(ej., fecha de
compartición
)

access_level
_id

INTEGER

name

VARCHAR

Nombre del
nivel de
acceso (ej.,
Lectura,
Escritura,
Edición)

permissions_
mask

INTEGER

Máscara de
bits o valor
que
representa

Sí

Sí

Referencia al
nivel de
acceso para
el recurso
compartido
en
AccessLevel

Identificador
único del
nivel de
acceso

los permisos
específicos
asociados a
este nivel de
acceso

La idoneidad de la estructura actual para representar permisos jerárquicos multinivel
depende de cómo se gestiona la relación `parent_folder_id` en `FolderDMS` y cómo
se utiliza la tabla `EffectivePermission` para aplicar estos permisos a través de la
jerarquía. La herencia de permisos, donde los permisos establecidos en una carpeta
se propagan a sus subcarpetas y documentos, es un requisito fundamental.[9] La
estructura actual debe implementar un mecanismo similar, posiblemente a través de
la tabla `EffectivePermission` o mediante lógica de aplicación que consulte las
relaciones entre carpetas. La gestión de diferentes niveles de acceso (por ejemplo,
lectura, escritura, eliminación) probablemente se maneja mediante la tabla
`AccessLevel` y su columna `permissions_mask`, que permite definir granularmente
las acciones permitidas para cada nivel.​
​
Sin embargo, la estructura actual podría presentar limitaciones para implementar
eficientemente la herencia de permisos a través de una jerarquía profunda de
documentos y carpetas. Si `FolderDMS` utiliza un modelo de lista de adyacencia
(donde cada carpeta simplemente apunta a su padre), la consulta de los permisos
efectivos para un usuario en un elemento específico, considerando la herencia, podría
requerir consultas recursivas o múltiples uniones, lo que puede ser ineficiente para
jerarquías muy anidadas.[10, 11] Mantener la tabla `EffectivePermission` consistente
con los cambios en la jerarquía o los permisos explícitos también podría ser complejo
y consumir muchos recursos, requiriendo la implementación de triggers o trabajos por
lotes para asegurar la integridad de los datos. Además, es importante considerar
cómo la estructura actual maneja las excepciones a los permisos heredados en
niveles inferiores de la jerarquía.​
​
La funcionalidad "Compartido conmigo" probablemente se implementa a través de la
tabla `Share`, que registra los elementos que se han compartido con usuarios
específicos. Esta tabla probablemente contiene referencias al documento o carpeta
compartida, al usuario con el que se comparte, al usuario que compartió el elemento
y al nivel de acceso otorgado.[12, 13] La eficiencia de la consulta para obtener todos

los elementos compartidos con un usuario dependerá de la indexación y la estructura
de la tabla `Share`, así como de las uniones necesarias con `DocumentDMS` y
`FolderDMS`. Es posible que la estructura actual trate los elementos compartidos de
manera diferente a los elementos dentro de la jerarquía de carpetas del usuario, lo
que podría generar inconsistencias en las comprobaciones de permisos o en la
experiencia del usuario.​
3.​ Modelo Alternativo: Tabla de Cierre para Jerarquías:​

El modelo de tabla de cierre es una solución eficaz para la gestión de datos
jerárquicos en bases de datos relacionales.10 Este modelo mantiene una tabla
separada que registra todas las relaciones ancestro-descendiente dentro de la
jerarquía. La tabla de cierre típicamente incluye columnas para el ID del ancestro,
el ID del descendiente y, opcionalmente, la profundidad de la relación.​
El modelo de tabla de cierre representa todas las relaciones
ancestro-descendiente, incluyendo la profundidad, de la siguiente manera: para
cada nodo en la jerarquía, la tabla de cierre almacena una fila donde el nodo es
tanto el ancestro como el descendiente, con una profundidad de 0.20 Para cada
relación directa padre-hijo, se almacena una fila con una profundidad de 1. Las
relaciones transitivas, como abuelo-nieto, también se registran, con una
profundidad creciente que indica el número de niveles de separación. La tabla 2
ilustra un ejemplo de un esquema de tabla de cierre para la gestión de la
jerarquía de carpetas.
Tabla

Columna

Tipo de
Datos

Clave
Primaria

FolderDMS

folder_id

INTEGER

Sí

name

VARCHAR

Nombre de
la carpeta

...

...

Otros
atributos de
la carpeta

ancestor_id

INTEGER

FolderClosur
e

Sí

Clave
Foránea

Descripción

Identificador
único de la
carpeta

FolderDMS
(folder_id)

ID de la
carpeta
ancestro

descendant_
id

INTEGER

depth

INTEGER

Sí

FolderDMS
(folder_id)

ID de la
carpeta
descendient
e
Distancia
entre el
ancestro y el
descendient
e (0 para el
mismo nodo,
1 para el hijo
directo, etc.)

El modelo de tabla de cierre ofrece varias ventajas en comparación con la estructura
actual. Permite consultar de manera eficiente todos los ancestros o descendientes de
un nodo con una sola unión.[10, 11] Determinar la profundidad de la jerarquía también
es sencillo. La herencia de permisos podría simplificarse consultando la tabla de
cierre para obtener todos los ancestros de un elemento y luego verificando los
permisos asociados a esos ancestros. Sin embargo, el modelo de tabla de cierre
también tiene desventajas. Requiere más espacio de almacenamiento debido a que se
almacenan todas las rutas. Las operaciones `INSERT` y `DELETE` son más complejas,
ya que requieren actualizaciones en la tabla de cierre. Además, podría ser necesario
implementar triggers para mantener automáticamente la tabla de cierre sincronizada
con los cambios en la jerarquía.[18, 20, 31] Es importante considerar que mover
subárboles (carpetas) podría ser más complejo con el modelo de tabla de cierre.[26]​
4.​ Recomendación y Justificación:​

Basándonos en el análisis de la estructura actual y el modelo alternativo, se
recomienda cambiar completamente el enfoque y adoptar el modelo de tabla de
cierre para la gestión de la jerarquía de carpetas y documentos, así como para la
implementación de la herencia de permisos. Si bien la estructura actual con una
tabla de permisos efectivos puede ofrecer un buen rendimiento para ciertas
consultas, presenta desafíos significativos en la gestión de la herencia en
jerarquías profundas y en el mantenimiento de la consistencia de los datos.​
El modelo de tabla de cierre, aunque introduce una mayor complejidad en las
operaciones de escritura (inserción, eliminación, movimiento de nodos), ofrece

ventajas sustanciales en el rendimiento de las consultas necesarias para la
gestión de permisos jerárquicos y la funcionalidad "Compartido conmigo". La
capacidad de consultar eficientemente todos los ancestros de un elemento
permite implementar la herencia de permisos de manera más directa y con un
mejor rendimiento, ya que se pueden determinar los permisos efectivos para un
usuario en un elemento específico consultando los permisos asociados a todos
sus ancestros en la jerarquía.​
Para la funcionalidad "Compartido conmigo", aunque se seguiría necesitando una
tabla Share para registrar los elementos compartidos con usuarios específicos, la
verificación de los permisos efectivos para estos elementos podría beneficiarse
del modelo de tabla de cierre. Al considerar la jerarquía en la que reside un
elemento compartido (si está dentro de una carpeta), se pueden aplicar las
reglas de herencia de permisos definidas a través de la tabla de cierre.​
La decisión de recomendar el modelo de tabla de cierre se basa en la
importancia de un rendimiento eficiente para las consultas de permisos en un
sistema de gestión documental, donde las comprobaciones de acceso son una
operación frecuente. Si bien la complejidad de las operaciones de escritura
aumenta, esta puede mitigarse mediante el uso de triggers a nivel de base de
datos que automaticen el mantenimiento de la tabla de cierre, asegurando la
consistencia de los datos y simplificando la lógica de la aplicación.
5.​ Implementación en PostgreSQL:
○​ Acceso a Datos:
■​ Tabla de Cierre:
■​ Para verificar los permisos de un usuario en un documento o carpeta
específica utilizando el modelo de tabla de cierre, se realizaría una
consulta que una la tabla de cierre (FolderClosure o una tabla similar
para documentos) con las tablas de usuarios, niveles de acceso y la
tabla de nodos (FolderDMS o DocumentDMS). La consulta filtraría por
el ID del usuario y el ID del elemento, considerando todos los
ancestros del elemento para determinar los permisos heredados. Por
ejemplo, para obtener los permisos de un usuario en una carpeta
específica:​
SQL​
SELECT al.name​
FROM FolderClosure fc​
JOIN FolderDMS f ON fc.ancestor_id = f.folder_id​
JOIN EffectivePermission ep ON f.folder_id = ep.folder_id​
JOIN AccessLevel al ON ep.access_level_id = al.access_level_id​
WHERE fc.descendant_id = <ID de la carpeta específica>​

AND ep.user_id = <ID del usuario>​
UNION​
SELECT al.name​
FROM FolderDMS f​
JOIN EffectivePermission ep ON f.folder_id = ep.folder_id​
JOIN AccessLevel al ON ep.access_level_id = al.access_level_id​
WHERE f.folder_id = <ID de la carpeta específica>​
AND ep.user_id = <ID del usuario>;​

■​ Para obtener todos los documentos y carpetas compartidos con un

usuario, se consultaría la tabla Share y se uniría con DocumentDMS y
FolderDMS. La verificación de los permisos efectivos para estos
elementos podría entonces utilizar la tabla de cierre para considerar la
jerarquía:​
SQL​
SELECT d.name AS document_name, s.access_level_id​
FROM Share s​
JOIN DocumentDMS d ON s.document_id = d.document_id​
WHERE s.shared_with_user_id = <ID del usuario>​
UNION​
SELECT f.name AS folder_name, s.access_level_id​
FROM Share s​
JOIN FolderDMS f ON s.folder_id = f.folder_id​
WHERE s.shared_with_user_id = <ID del usuario>;​

■​ Para consultar la jerarquía de carpetas y documentos, se uniría la

tabla de cierre con FolderDMS y DocumentDMS. Por ejemplo, para
obtener toda la jerarquía de carpetas:​
SQL​
SELECT f.name AS descendant, p.name AS ancestor, fc.depth​
FROM FolderClosure fc​
JOIN FolderDMS f ON fc.descendant_id = f.folder_id​
JOIN FolderDMS p ON fc.ancestor_id = p.folder_id​
ORDER BY fc.depth;​

■​ Para consultar los permisos efectivos para un usuario en un elemento

específico, considerando la herencia, se consultaría la tabla de cierre
para todos los ancestros del elemento y se uniría con las tablas de
permisos:​
SQL​

SELECT al.name​
FROM FolderClosure fc​
JOIN FolderDMS f ON fc.ancestor_id = f.folder_id​
JOIN EffectivePermission ep ON f.folder_id = ep.folder_id​
JOIN AccessLevel al ON ep.access_level_id = al.access_level_id​
WHERE fc.descendant_id = <ID del elemento>​
AND ep.user_id = <ID del usuario>​
ORDER BY fc.depth;​

○​ Creación de Registros:
■​ Tabla de Cierre:
■​ Para crear un nuevo documento, se insertaría un registro en la tabla

DocumentDMS con la información del documento.
■​ Para crear una nueva carpeta, se insertaría un registro en la tabla
FolderDMS con la información de la carpeta. Además, se deberían
insertar registros en la tabla de cierre (FolderClosure). Esto incluiría
una entrada auto-referencial (ancestor_id igual a descendant_id y
profundidad 0) y entradas para cada ancestro de la nueva carpeta. Si
la nueva carpeta es hija de otra, se consultarían los ancestros de la
carpeta padre en la tabla de cierre y se insertarían nuevas filas para la
nueva carpeta con esos ancestros y una profundidad incrementada en
1. Por ejemplo, para insertar una nueva carpeta con ID new_folder_id
como hija de una carpeta con ID parent_folder_id:​
SQL​
-- Insertar la nueva carpeta​
INSERT INTO FolderDMS (folder_id, parent_folder_id, name) VALUES

(<new_folder_id>, <parent_folder_id>, '<nombre de la nueva carpeta>');​
​
-- Insertar la entrada auto-referencial en la tabla de cierre​
INSERT INTO FolderClosure (ancestor_id, descendant_id, depth) VALUES
(<new_folder_id>, <new_folder_id>, 0);​
​
-- Insertar entradas para los ancestros (incluyendo el padre)​
INSERT INTO FolderClosure (ancestor_id, descendant_id, depth)​
SELECT ancestor_id, <new_folder_id>, depth + 1​
FROM FolderClosure​
WHERE descendant_id = <parent_folder_id>;​
■​ Para crear un nuevo permiso, se insertaría un registro en la tabla

EffectivePermission con el ID del usuario, el ID del documento o

carpeta y el ID del nivel de acceso.
6.​ Integración con Prisma ORM:
○​ Definición de Modelos de Prisma:
■​ Para la estructura de base de datos con tabla de cierre, los modelos de
Prisma correspondientes a las tablas DocumentDMS, FolderDMS,
FolderClosure, EffectivePermission, Share y AccessLevel se definirían de
la siguiente manera:​
Fragmento de código​

model DocumentDMS {​
id
Int
@id @default(autoincrement())​
folderId Int​
name
String​
folder FolderDMS @relation(fields: [folderId], references: [id])​
effectivePermissions EffectivePermission​
shares
Share​
}​
​
model FolderDMS {​
id
Int
@id @default(autoincrement())​
parentFolderId Int?​
name
String​
documents
DocumentDMS​
parentFolder FolderDMS? @relation("FolderHierarchy", fields:
[parentFolderId], references: [id], onDelete: Cascade, onUpdate:
Cascade)​
childFolders FolderDMS @relation("FolderHierarchy")​
ancestorClosure FolderClosure @relation("Ancestor")​
descendantClosure FolderClosure @relation("Descendant")​
effectivePermissions EffectivePermission​
shares
Share​
}​
​
model FolderClosure {​
ancestorId Int​
descendantId Int​
depth
Int​
ancestor FolderDMS @relation("Ancestor", fields: [ancestorId],
references: [id], onDelete: Cascade, onUpdate: Cascade)​
descendant FolderDMS @relation("Descendant", fields: [descendantId],

references: [id], onDelete: Cascade, onUpdate: Cascade)​
​
@@id([ancestorId, descendantId])​
}​
​
model EffectivePermission {​
id
Int
@id @default(autoincrement())​
userId
Int​
documentId Int?​
folderId
Int?​
accessLevelId Int​
document
DocumentDMS? @relation(fields: [documentId],
references: [id], onDelete: Cascade, onUpdate: Cascade)​
folder
FolderDMS? @relation(fields: [folderId], references: [id],
onDelete: Cascade, onUpdate: Cascade)​
accessLevel AccessLevel @relation(fields: [accessLevelId], references:
[id], onDelete: Cascade, onUpdate: Cascade)​
}​
​
model Share {​
id
Int
@id @default(autoincrement())​
documentId
Int?​
folderId
Int?​
sharedWithUserId Int​
accessLevelId
Int​
sharedByUserId Int​
document
DocumentDMS? @relation(fields: [documentId],
references: [id], onDelete: Cascade, onUpdate: Cascade)​
folder
FolderDMS? @relation(fields: [folderId], references: [id],
onDelete: Cascade, onUpdate: Cascade)​
accessLevel
AccessLevel @relation(fields: [accessLevelId],
references: [id], onDelete: Cascade, onUpdate: Cascade)​
}​
​
model AccessLevel {​
id
Int
@id @default(autoincrement())​
name
String​
permissionsMask Int​
effectivePermissions EffectivePermission​

shares
}​

Share​

○​ Uso del Cliente de Prisma para Consultas:
■​ Para verificar los permisos de un usuario en una carpeta específica:​
TypeScript​
const permissions = await prisma.folderClosure.findMany({​
where: {​
descendantId: folderId,​
ancestor: {​
effectivePermissions: {​
some: {​
userId: userId,​
folderId: { not: null },​

},​
},​
},​
},​
include: {​
ancestor: {​
include: {​
effectivePermissions: {​
where: { userId: userId },​
include: { accessLevel: true },​

},​
},​
},​
},​
});​
■​ Para obtener todos los documentos y carpetas compartidos con un
usuario:​
TypeScript​
const sharedItems = await prisma.share.findMany({​
where: { sharedWithUserId: userId },​
include: { document: true, folder: true, accessLevel: true },​

});​
■​ Para consultar la jerarquía de carpetas:​

TypeScript​
const folderHierarchy = await prisma.folderClosure.findMany({​
include: {​
ancestor: { select: { id: true, name: true } },​
descendant: { select: { id: true, name: true } },​

},​
orderBy: { depth: 'asc' },​

});​
■​ Para obtener los permisos efectivos para un usuario en una carpeta
específica (simplificado):​
TypeScript​
const effectivePermissions = await prisma.effectivePermission.findMany({​
where: {​
userId: userId,​
folderId: folderId,​

},​
include: { accessLevel: true },​

});​
○​ Uso del Cliente de Prisma para Crear Registros:
■​ Para crear una nueva carpeta:​
TypeScript​
const newFolder = await prisma.folderDMS.create({​
data: {​
name: folderName,​
parentFolderId: parentFolderId,​
ancestorClosure: {​
create: [​

{ ancestorId: newFolderId, depth: 0 }, // Auto-referencia​
//... (Lógica para crear entradas de ancestros basada en el parentFolderId)​

],​
},​
},​
});​
■​ Para crear un nuevo documento:​
TypeScript​
const newDocument = await prisma.documentDMS.create({​
data: {​

name: documentName,​
folderId: folderId,​

},​
});​
■​ Para crear un nuevo permiso:​
TypeScript​
const newPermission = await prisma.effectivePermission.create({​
data: {​
userId: userId,​
folderId: folderId,​
accessLevelId: accessLevelId,​

},​
});​
7.​ Conclusión:​

El análisis presentado sugiere que la adopción del modelo de tabla de cierre para
la gestión de la jerarquía de carpetas y documentos ofrece ventajas significativas
en términos de rendimiento de consultas para la gestión de permisos jerárquicos
y la funcionalidad "Compartido conmigo". Si bien este modelo introduce una
mayor complejidad en las operaciones de escritura, los beneficios en la eficiencia
de las consultas, especialmente en sistemas con jerarquías profundas y un alto
volumen de comprobaciones de permisos, justifican el cambio de enfoque. Se
recomienda realizar pruebas de rendimiento exhaustivas con volúmenes de datos
y patrones de consulta realistas para validar los beneficios esperados. También
se deben considerar el impacto de la migración en los datos existentes y la curva
de aprendizaje para el equipo con respecto al nuevo modelo.
Obras citadas
1.​ Organize your files | Data management - MIT Libraries, fecha de acceso: abril 16,

2025, https://libraries.mit.edu/data-management/store/organize/

2.​ Directory Structure - Harvard Biomedical Data Management, fecha de acceso:

abril 16, 2025,
https://datamanagement.hms.harvard.edu/plan-design/directory-structure
3.​ Designing a data file structure - CESSDA Data Management Expert Guide, fecha
de acceso: abril 16, 2025,
https://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen
t/Designing-a-data-file-structure
4.​ File naming and folder structure - CESSDA Data Management Expert Guide,
fecha de acceso: abril 16, 2025,

https://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen
t/File-naming-and-folder-structure
5.​ File and Folder Organization - long draft - UC Merced Library, fecha de acceso:
abril 16, 2025, https://library.ucmerced.edu/node/66751
6.​ The Guide to Folder Structures - SuiteFiles, fecha de acceso: abril 16, 2025,
https://www.suitefiles.com/guides/folder-structures-guide/
7.​ Collaborative Document Management - Interfacing Technologies, fecha de
acceso: abril 16, 2025,
https://interfacing.com/collaborative-document-management
8.​ What is a Document Management System? - IRIS Software Group, fecha de
acceso: abril 16, 2025,
https://www.irisglobal.com/blog/what-is-a-document-management-system/
9.​ Understanding Permission Inheritance - Seeq Knowledge Base, fecha de acceso:
abril 16, 2025,
https://support.seeq.com/kb/R64/cloud/understanding-permission-inheritance
10.​Hierarchical models in PostgreSQL | Ackee blog, fecha de acceso: abril 16, 2025,
https://www.ackee.agency/blog/hierarchical-models-in-postgresql
11.​ Closure Table | The Cache • Fueled Engineering, fecha de acceso: abril 16, 2025,
https://fueled.com/the-cache/posts/backend/closure-table/
12.​Database design for file sharing system like Google drive : r/AskProgramming Reddit, fecha de acceso: abril 16, 2025,
https://www.reddit.com/r/AskProgramming/comments/1g3msfs/database_design
_for_file_sharing_system_like/
13.​How to design a functionality to share content? - Software Engineering Stack
Exchange, fecha de acceso: abril 16, 2025,
https://softwareengineering.stackexchange.com/questions/348606/how-to-desig
n-a-functionality-to-share-content
14.​SQL Server Closure Tables - Simple Talk - Redgate Software, fecha de acceso:
abril 16, 2025,
https://www.red-gate.com/simple-talk/databases/sql-server/t-sql-programmingsql-server/sql-server-closure-tables/
15.​Recursive CTE vs closure table for storing hierarchical information : r/PostgreSQL
- Reddit, fecha de acceso: abril 16, 2025,
https://www.reddit.com/r/PostgreSQL/comments/1777s0t/recursive_cte_vs_closu
re_table_for_storing/
16.​Transitive Closure in PostgreSQL - Remind Engineering, fecha de acceso: abril 16,
2025, https://engineering.remind.com/Transitive-Closure-In-PostgreSQL/
17.​franzose/ClosureTable: Adjacency List'ed Closure Table database design pattern
implementation for the Laravel framework. - GitHub, fecha de acceso: abril 16,
2025, https://github.com/franzose/ClosureTable
18.​This is a mysql and postgresql store procedure and trigger implementation of
closure table in RDBMS about hierarchy data model. - GitHub, fecha de acceso:
abril 16, 2025, https://github.com/developerworks/hierarchy-data-closure-table
19.​The relational modeling of hierarchical data in biodiversity databases - Oxford
Academic, fecha de acceso: abril 16, 2025,

https://academic.oup.com/database/article/doi/10.1093/database/baae107/781784
3
20.​Store Hierarchical Data Seamlessly | PostgreSQL - Closure Table, fecha de
acceso: abril 16, 2025,
https://technobytz.com/closure_table_store_hierarchical_data.html
21.​WillSoss/closure-tree: A closure table implementation in C#/MSSQL. - GitHub,
fecha de acceso: abril 16, 2025, https://github.com/WillSoss/closure-tree
22.​Choice of Database schema for storing folder system - Stack Overflow, fecha de
acceso: abril 16, 2025,
https://stackoverflow.com/questions/13104601/choice-of-database-schema-forstoring-folder-system
23.​Moving Subtrees in Closure Table Hierarchies - Percona, fecha de acceso: abril 16,
2025, https://www.percona.com/blog/moving-subtrees-in-closure-table/
24.​The simplest(?) way to do tree-based queries in SQL - dirtSimple.org, fecha de
acceso: abril 16, 2025,
https://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html
25.​How can I create a closure table using data from an adjacency list? - Stack
Overflow, fecha de acceso: abril 16, 2025,
https://stackoverflow.com/questions/12621873/how-can-i-create-a-closure-table
-using-data-from-an-adjacency-list
26.​Rendering Trees with Closure Tables – Keeping It Simple - Karwin, fecha de
acceso: abril 16, 2025,
https://karwin.com/blog/index.php/2010/03/24/rendering-trees-with-closure-tabl
es/
27.​Hierarchical Structures in PostgreSQL (2020) - Hacker News, fecha de acceso:
abril 16, 2025, https://news.ycombinator.com/item?id=27631765
28.​Working with Graphs in Postgres Part 2: Extending the Closure Table Pattern to
Support DAGs - Lucas Nagle, fecha de acceso: abril 16, 2025,
https://lnagle.github.io/extended-closure-table-pattern.html
29.​data modeling - Managing hierarchies in SQL: MPTT/nested sets vs ..., fecha de
acceso: abril 16, 2025,
https://stackoverflow.com/questions/8196175/managing-hierarchies-in-sql-mpttnested-sets-vs-adjacency-lists-vs-storing-path
30.​Moving in Closure Table with Multiple Parents - sql - Stack Overflow, fecha de
acceso: abril 16, 2025,
https://stackoverflow.com/questions/9641932/moving-in-closure-table-with-multi
ple-parents
31.​Hierarchical data using closure table, how to ensure that a column is unique within
the parent node? - DBA Stack Exchange, fecha de acceso: abril 16, 2025,
https://dba.stackexchange.com/questions/269404/hierarchical-data-using-closur
e-table-how-to-ensure-that-a-column-is-unique-wit
32.​Implementing version history with a closure table schema - Stack Overflow, fecha
de acceso: abril 16, 2025,
https://stackoverflow.com/questions/13457479/implementing-version-history-wit
h-a-closure-table-schema

33.​Worked example of closure tables with from and thru dates - DBA Stack

Exchange, fecha de acceso: abril 16, 2025,
https://dba.stackexchange.com/questions/230966/worked-example-of-closure-t
ables-with-from-and-thru-dates
34.​Use closure tables to implement file cache without full path column · Issue #4209
· owncloud/core - GitHub, fecha de acceso: abril 16, 2025,
https://github.com/owncloud/core/issues/4209
35.​When inserting why does a closure table point to itself - Stack Overflow, fecha de
acceso: abril 16, 2025,
https://stackoverflow.com/questions/22416571/when-inserting-why-does-a-closu
re-table-point-to-itself
36.​hierarchical data in a database: recursive query vs. closure tables vs. graph
database, fecha de acceso: abril 16, 2025,
https://stackoverflow.com/questions/7497812/hierarchical-data-in-a-database-re
cursive-query-vs-closure-tables-vs-graph-da
37.​How to Store and Query Categories : r/PHP - Reddit, fecha de acceso: abril 16,
2025,
https://www.reddit.com/r/PHP/comments/l72ve8/how_to_store_and_query_categ
ories/
38.​How would you model a file tree? : r/SQL - Reddit, fecha de acceso: abril 16, 2025,
https://www.reddit.com/r/SQL/comments/rt3d9a/how_would_you_model_a_file_tr
ee/
39.​Nested Sets vs Closure Table in real life apps : r/PHP - Reddit, fecha de acceso:
abril 16, 2025,
https://www.reddit.com/r/PHP/comments/3mgomv/nested_sets_vs_closure_table_
in_real_life_apps/



Este analisis fue realizado por Aaron Santander