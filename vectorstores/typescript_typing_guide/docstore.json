[["0",{"pageContent":"Typescript typing Guide\r\n1. Introducci√≥n\r\nObjetivo del Documento\r\nExplicar la importancia del tipado en TypeScript y establecer lineamientos\r\nclaros sobre el uso de interface, type, any, unknown y gen√©ricos, adem√°s de\r\nlos tipos avanzados y enum, dentro del equipo de desarrollo en LearUp.\r\n\r\nBeneficios del Tipado\r\nMejora de la seguridad del c√≥digo.\r\nDetecci√≥n temprana de errores.\r\nMejor documentaci√≥n y autocompletado en IDEs.\r\n\r\n2. Uso de Interfaces\r\nDefinici√≥n de Interfaces\r\nUna interface se usa para definir la estructura de un objeto de manera clara y\r\nextensible. Se recomienda para estructuras que puedan evolucionar con el\r\ntiempo y ser extendidas.\r\n\r\nSintaxis B√°sica\r\ninterface User {\r\nid: number;\r\nname: string;\r\nemail: string;\r\n}\r\n\r\nExtensi√≥n de Interfaces\r\nPermite heredar propiedades de otras interfaces, facilitando la reutilizaci√≥n del\r\nc√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":1,"to":38}}}}],["1",{"pageContent":"c√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {\r\nposition: string;\r\n}\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Modelado de datos de usuario en una API.\r\nfunction getUser(): User {\r\nreturn { id: 1, name: \"John Doe\", email: \"john@company.com\" };\r\n}\r\n\r\n3. Uso de Types\r\nDefinici√≥n de Types\r\nUn type permite definir valores basados en los tipos primitivos de TypeScript:\r\n\r\nTipos B√°sicos\r\n// Primitive Types\r\ntype Text = string;\r\n// Text strings\r\ntype Age = number;\r\n// Numbers (integers or decimals)\r\ntype IsActive = boolean; // True or false values\r\ntype CreatedAt = Date; // Dates and times\r\ntype UniqueID = symbol; // Unique identifiers\r\ntype AnyValue = any; // Any type (avoid using it)\r\ntype UnknownValue = unknown; // Any type, but safer than 'any'\r\ntype Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":28,"to":68}}}}],["2",{"pageContent":"type Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2\r\n\r\n\fstring / number / boolean: Datos b√°sicos como nombres, edades o\r\nestados.\r\nDate ‚Üí Fechas en APIs o registros.\r\nsymbol ‚Üí Identificadores √∫nicos en estructuras avanzadas.\r\nvoid / never ‚Üí Definir funciones con retorno vac√≠o o errores.\r\nany / unknown ‚Üí Casos donde el tipo es incierto (se recomienda unknown\r\nsobre any).\r\n\r\nTipos de Uni√≥n e Intersecci√≥n\r\nUni√≥n (|): Permite m√∫ltiples tipos posibles.\r\nIntersecci√≥n (&): Combina m√∫ltiples tipos en uno solo\r\n\r\nüìå\r\n\r\n//\r\nUnion: A value can be one type or another\r\ntype ID = string | number;\r\ntype Status = \"active\" | \"inactive\" | \"pending\";\r\nlet userId: ID = 123;\r\nuserId = \"abc123\"; //\r\n\r\n‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":63,"to":101}}}}],["3",{"pageContent":"‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//\r\nIntersection: Combines multiple types into one\r\ntype User = { id: number; name: string };\r\ntype Employee = User & { position: string; salary: number };\r\nconst employee: Employee = {\r\nid: 1,\r\nname: \"Alice\",\r\nposition: \"Developer\",\r\nsalary: 50000\r\n};\r\n//\r\n\r\n‚ùå Error if a property is missing (e.g., position or salary)\r\n\r\nTypescript typing Guide\r\n\r\n3\r\n\r\n\fTipos Literales\r\nRestringen un valor a un conjunto espec√≠fico.\r\ntype Role = \"admin\" | \"user\" | \"guest\"; // Can only be one of these values\r\n\r\nTipos de Funciones\r\nDefinen la firma de una funci√≥n, asegurando los tipos de sus par√°metros y\r\nrespuesta.\r\n// Define a function type\r\ntype MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":91,"to":130}}}}],["4",{"pageContent":"type MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;\r\n\r\n‚û°Ô∏è 8\r\n‚û°Ô∏è 15\r\n\r\nconsole.log(sum(5, 3));\r\n//\r\nconsole.log(multiply(5, 3)); //\r\n\r\n4. Uso de Tipos Gen√©ricos\r\nDefinici√≥n de Tipos Gen√©ricos\r\nLos tipos gen√©ricos permiten crear estructuras reutilizables que trabajan con\r\ntipos din√°micos en lugar de un tipo fijo. Esto los hace flexibles y escalables.\r\n\r\nSintaxis basica de Gen√©ricos\r\nfunction identity<T>(arg: T): T {\r\nreturn arg;\r\n}\r\n\r\n‚û°Ô∏è 10 (type: number)\r\nconsole.log(identity(\"Hola\")); // ‚û°Ô∏è \"Hola\" (type: string)\r\nconsole.log(identity(10));\r\n\r\nT\r\n\r\n//\r\n\r\nes un par√°metro de tipo que representa un tipo din√°mico.\r\n\r\nTypescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":127,"to":166}}}}],["5",{"pageContent":"Typescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir\r\nestructuras reutilizables sin perder el tipado fuerte.\r\ninterface ApiResponse<T> {\r\ndata: T | null;\r\nstatus: number;\r\nerror?: string;\r\n}\r\nconst userResponse: ApiResponse<{ id: number; name: string }> = { // 'T' i\r\nn this case is an object with 'id' and 'name'\r\n\r\n‚úÖ\r\n\r\ndata: { id: 1, name: \"Alice\" }, //\r\nUser data retrieved successfully\r\nstatus: 200\r\n//\r\nSuccessful HTTP status code\r\n\r\n‚úÖ\r\n\r\n};\r\n\r\nconst errorResponse: ApiResponse<null> = { // 'T' in this case is null\r\n\r\n‚ùå No data available\r\n// ‚ùå Status code indicating 'Not Found'\r\nerror: \"User not found\" // ‚úÖ Error message\r\ndata: null,\r\nstatus: 404,\r\n\r\n};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":159,"to":207}}}}],["6",{"pageContent":"};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {\r\ndata: T | null; // Holds the response data or null if there's an error\r\nstatus: number;\r\nerror?: string;\r\n}\r\n//\r\n\r\nüìå Generic function to fetch data from an API\r\n\r\nasync function fetchData<T>(url: string): Promise<ApiResponse<T>> {\r\n\r\nTypescript typing Guide\r\n\r\n5\r\n\r\n\ftry {\r\nconst response = await fetch(url);\r\n// Check if the response is not successful\r\nif (!response.ok) {\r\nreturn { data: null, status: response.status, error: response.statusTex\r\nt };\r\n}\r\n// Parse and return the JSON response\r\nconst data: T = await response.json();\r\nreturn { data, status: response.status };\r\n} catch (error) {\r\n// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":196,"to":239}}}}],["7",{"pageContent":"// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown\r\nany: Permite cualquier tipo sin restricciones, deshabilitando la seguridad de\r\ntipos.\r\nunknown: Acepta cualquier tipo, pero requiere validaci√≥n antes de su uso.\r\n\r\nCu√°ndo usar any\r\nA pesar de que unknown es generalmente m√°s seguro, existen situaciones\r\nespec√≠ficas donde any puede ser apropiado:\r\nMigraciones graduales: Cuando se migra c√≥digo JavaScript a TypeScript\r\nde forma incremental.\r\nIntegraciones con bibliotecas externas: Al trabajar con bibliotecas sin\r\ndefiniciones de tipos.\r\nPrototipos r√°pidos: En fases iniciales de desarrollo donde la prioridad es la\r\nvelocidad.\r\n\r\nTypescript typing Guide\r\n\r\n6\r\n\r\n\fDatos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":233,"to":264}}}}],["8",{"pageContent":"Datos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime\r\n\r\n‚úÖ Se permite sin validaci√≥n, puede causar error\r\n\r\nEjemplo con unknown (Recomendado)\r\nEl tipo unknown debe ser la opci√≥n predeterminada cuando se necesita\r\nflexibilidad de tipos:\r\nlet value: unknown;\r\nvalue = \"Texto\";\r\nvalue = 42;\r\nif (typeof value === \"string\") {\r\nlet str: string = value; //\r\nSolo se permite tras validaci√≥n\r\n}\r\n\r\n‚úÖ\r\n\r\n6. Tipos Avanzados\r\nTipos Condicionales\r\nPermiten evaluar un tipo en tiempo de compilaci√≥n.\r\ntype IsString<T> = T extends string ? \"Yes\" : \"No\";\r\ntype Result = IsString<number>; // \"No\"\r\n\r\nInferencia de Tipos\r\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":258,"to":297}}}}],["9",{"pageContent":"function getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude\r\nRecord<K, V> : Permite definir un objeto donde las claves (K) tienen un tipo\r\n\r\nespec√≠fico y los valores (V) siguen una estructura determinada.\r\ntype Users = Record<string, { id: number; name: string }>;\r\nconst users: Users = {\r\nuser1: { id: 1, name: \"Alice\" },\r\nuser2: { id: 2, name: \"Bob\" }\r\n};\r\nOmit<T, K> :\r\n\r\nElimina propiedades espec√≠ficas de un tipo.\r\n\r\ntype User = { id: number; name: string; email: string };\r\ntype UserWithoutEmail = Omit<User, \"email\">;\r\nExclude<T, U> : Elimina tipos de una uni√≥n.\r\n\r\ntype Status = \"active\" | \"inactive\" | \"banned\";\r\ntype ActiveStatus = Exclude<Status, \"banned\">;\r\n\r\nTipos Utilitarios Mapeados\r\nSe usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":288,"to":323}}}}],["10",{"pageContent":"Se usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type\r\ntype User = {\r\nid: number;\r\nname: string;\r\n};\r\ntype ReadonlyUser = ReadonlyWrapper<User>;\r\n// Equivalente a:\r\n\r\nTypescript typing Guide\r\n\r\n8\r\n\r\n\f// type ReadonlyUser = { readonly id: number; readonly name: string; }\r\nconst user: ReadonlyUser = { id: 1, name: \"Juan\" };\r\nuser.name = \"Pedro\"; //\r\ndonly\r\n\r\n‚ùå Error: No se puede modificar una propiedad rea\r\n\r\nReadonly, Partial, Required y Pick\r\nEstos tipos utilitarios permiten manipular las propiedades de un objeto:\r\ntype User = {\r\nid: number;\r\nname: string;\r\nemail?: string;\r\n};\r\nReadonly<T> : Convierte todas las propiedades en solo lectura.\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\nPartial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":318,"to":355}}}}],["11",{"pageContent":"Partial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.\r\n\r\ntype RequiredUser = Required<User>;\r\nPick<T, K> : Selecciona propiedades espec√≠ficas de un tipo.\r\n\r\ntype UserIdAndName = Pick<User, \"id\" | \"name\">;\r\nPara ampliar la informacion sobre otros utility types pueden visitar la\r\ndocumentacion oficial https://www.typescriptlang.org/docs/handbook/utilitytypes.html\r\n\r\nTypescript typing Guide\r\n\r\n9\r\n\r\n\f8. Uso de Enum en TypeScript\r\nDefinici√≥n de Enum\r\nUn enum es un tipo especial en TypeScript que permite definir un conjunto de\r\nconstantes con nombre.\r\n\r\nTipos de Enum\r\nEnum Num√©rico\r\nPor defecto, los enums asignan valores num√©ricos comenzando desde 0:\r\nenum Direction {\r\nUp, // 0\r\nDown, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":352,"to":386}}}}],["12",{"pageContent":"Down, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:\r\nenum Direction {\r\nUp = 1,\r\nDown, // 2\r\nLeft, // 3\r\nRight // 4\r\n}\r\n\r\nEnum de Cadenas\r\nenum UserRole {\r\nAdmin = \"ADMIN\",\r\nUser = \"USER\",\r\nGuest = \"GUEST\"\r\n\r\nTypescript typing Guide\r\n\r\n10\r\n\r\n\f}\r\n// No hay reverse mapping en enums de cadenas\r\nconsole.log(UserRole.Admin); // \"ADMIN\"\r\n\r\nCaracter√≠stica de Reverse Mapping\r\nLos enums num√©ricos generan un mapa bidireccional (nombre a valor y valor a\r\nnombre):\r\nenum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconsole.log(Direction[2]); // \"Down\"\r\nEsto aumenta el tama√±o del c√≥digo generado, ya que se crea un objeto m√°s\r\ncomplejo.\r\n\r\nEnums Const\r\nLos const enum se eliminan completamente durante la compilaci√≥n,\r\nreemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":378,"to":427}}}}],["13",{"pageContent":"reemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconst dir = Direction.Up; // Se compila a: const dir = 1;\r\n\r\nEjemplo Pr√°ctico\r\n\r\nTypescript typing Guide\r\n\r\n11\r\n\r\n\fCaso de uso: Definir roles de usuario en una aplicaci√≥n.\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Full access\";\r\n}\r\nreturn \"Limited access\";\r\n}\r\n\r\n9. Enum vs Tipos literales\r\nUsar enum cuando:\r\nSe requiere una representaci√≥n en tiempo de ejecuci√≥n\r\nexiste en JavaScript despu√©s de la compilaci√≥n, lo que permite\r\nacceder a sus valores en tiempo de ejecuci√≥n.\r\nenum\r\n\r\n√ötil si necesitas valores asignados autom√°ticamente o bidireccionales\r\n(clave-valor y valor-clave).\r\nLos valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":423,"to":459}}}}],["14",{"pageContent":"Los valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos\r\nSi necesitas asignar valores personalizados, como cadenas o n√∫meros\r\nespec√≠ficos.\r\n\r\nEjemplo de enum\r\nenum UserRole {\r\nAdmin = \"admin\",\r\nUser = \"user\",\r\nGuest = \"guest\"\r\n}\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Acceso total\";\r\n\r\nTypescript typing Guide\r\n\r\n12\r\n\r\n\f}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(UserRole.Admin)); // \"Acceso total\"\r\n\r\nUsar type con uniones literales cuando:\r\nNo se necesita una representaci√≥n en tiempo de ejecuci√≥n\r\ndesaparece despu√©s de la compilaci√≥n, mejorando el rendimiento\r\ny reduciendo el tama√±o del c√≥digo.\r\ntype\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":456,"to":490}}}}],["15",{"pageContent":"type\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada\r\nSi solo necesitas definir un conjunto de valores sin m√©todos\r\nadicionales.\r\n\r\nEjemplo de type con uniones literales\r\ntype UserRole = \"admin\" | \"user\" | \"guest\";\r\nfunction getPermissions(role: UserRole) {\r\nif (role === \"admin\") {\r\nreturn \"Acceso total\";\r\n}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(\"admin\")); // \"Acceso total\"\r\n\r\n10. Recursos Adicionales\r\nhttps://www.typescriptlang.org/docs/handbook/intro.html\r\n\r\nTypescript typing Guide\r\n\r\n13\r\n\r\n\fhttps://docs.aws.amazon.com/prescriptive-guidance/latest/best-practicescdk-typescript-iac/typescript-best-practices.html\r\nhttps://basarat.gitbook.io/typescript/type-system\r\nIv√°n Santander\r\n\r\nTypescript typing Guide\r\n\r\n14\r\n\r\n\f\r\n\r\n\r\nGuia Escrita por Ivan Santander","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":486,"to":522}}}}],["16",{"pageContent":"Typescript typing Guide\r\n1. Introducci√≥n\r\nObjetivo del Documento\r\nExplicar la importancia del tipado en TypeScript y establecer lineamientos\r\nclaros sobre el uso de interface, type, any, unknown y gen√©ricos, adem√°s de\r\nlos tipos avanzados y enum, dentro del equipo de desarrollo en LearUp.\r\n\r\nBeneficios del Tipado\r\nMejora de la seguridad del c√≥digo.\r\nDetecci√≥n temprana de errores.\r\nMejor documentaci√≥n y autocompletado en IDEs.\r\n\r\n2. Uso de Interfaces\r\nDefinici√≥n de Interfaces\r\nUna interface se usa para definir la estructura de un objeto de manera clara y\r\nextensible. Se recomienda para estructuras que puedan evolucionar con el\r\ntiempo y ser extendidas.\r\n\r\nSintaxis B√°sica\r\ninterface User {\r\nid: number;\r\nname: string;\r\nemail: string;\r\n}\r\n\r\nExtensi√≥n de Interfaces\r\nPermite heredar propiedades de otras interfaces, facilitando la reutilizaci√≥n del\r\nc√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":1,"to":38}}}}],["17",{"pageContent":"c√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {\r\nposition: string;\r\n}\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Modelado de datos de usuario en una API.\r\nfunction getUser(): User {\r\nreturn { id: 1, name: \"John Doe\", email: \"john@company.com\" };\r\n}\r\n\r\n3. Uso de Types\r\nDefinici√≥n de Types\r\nUn type permite definir valores basados en los tipos primitivos de TypeScript:\r\n\r\nTipos B√°sicos\r\n// Primitive Types\r\ntype Text = string;\r\n// Text strings\r\ntype Age = number;\r\n// Numbers (integers or decimals)\r\ntype IsActive = boolean; // True or false values\r\ntype CreatedAt = Date; // Dates and times\r\ntype UniqueID = symbol; // Unique identifiers\r\ntype AnyValue = any; // Any type (avoid using it)\r\ntype UnknownValue = unknown; // Any type, but safer than 'any'\r\ntype Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":28,"to":68}}}}],["18",{"pageContent":"type Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2\r\n\r\n\fstring / number / boolean: Datos b√°sicos como nombres, edades o\r\nestados.\r\nDate ‚Üí Fechas en APIs o registros.\r\nsymbol ‚Üí Identificadores √∫nicos en estructuras avanzadas.\r\nvoid / never ‚Üí Definir funciones con retorno vac√≠o o errores.\r\nany / unknown ‚Üí Casos donde el tipo es incierto (se recomienda unknown\r\nsobre any).\r\n\r\nTipos de Uni√≥n e Intersecci√≥n\r\nUni√≥n (|): Permite m√∫ltiples tipos posibles.\r\nIntersecci√≥n (&): Combina m√∫ltiples tipos en uno solo\r\n\r\nüìå\r\n\r\n//\r\nUnion: A value can be one type or another\r\ntype ID = string | number;\r\ntype Status = \"active\" | \"inactive\" | \"pending\";\r\nlet userId: ID = 123;\r\nuserId = \"abc123\"; //\r\n\r\n‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":63,"to":101}}}}],["19",{"pageContent":"‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//\r\nIntersection: Combines multiple types into one\r\ntype User = { id: number; name: string };\r\ntype Employee = User & { position: string; salary: number };\r\nconst employee: Employee = {\r\nid: 1,\r\nname: \"Alice\",\r\nposition: \"Developer\",\r\nsalary: 50000\r\n};\r\n//\r\n\r\n‚ùå Error if a property is missing (e.g., position or salary)\r\n\r\nTypescript typing Guide\r\n\r\n3\r\n\r\n\fTipos Literales\r\nRestringen un valor a un conjunto espec√≠fico.\r\ntype Role = \"admin\" | \"user\" | \"guest\"; // Can only be one of these values\r\n\r\nTipos de Funciones\r\nDefinen la firma de una funci√≥n, asegurando los tipos de sus par√°metros y\r\nrespuesta.\r\n// Define a function type\r\ntype MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":91,"to":130}}}}],["20",{"pageContent":"type MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;\r\n\r\n‚û°Ô∏è 8\r\n‚û°Ô∏è 15\r\n\r\nconsole.log(sum(5, 3));\r\n//\r\nconsole.log(multiply(5, 3)); //\r\n\r\n4. Uso de Tipos Gen√©ricos\r\nDefinici√≥n de Tipos Gen√©ricos\r\nLos tipos gen√©ricos permiten crear estructuras reutilizables que trabajan con\r\ntipos din√°micos en lugar de un tipo fijo. Esto los hace flexibles y escalables.\r\n\r\nSintaxis basica de Gen√©ricos\r\nfunction identity<T>(arg: T): T {\r\nreturn arg;\r\n}\r\n\r\n‚û°Ô∏è 10 (type: number)\r\nconsole.log(identity(\"Hola\")); // ‚û°Ô∏è \"Hola\" (type: string)\r\nconsole.log(identity(10));\r\n\r\nT\r\n\r\n//\r\n\r\nes un par√°metro de tipo que representa un tipo din√°mico.\r\n\r\nTypescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":127,"to":166}}}}],["21",{"pageContent":"Typescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir\r\nestructuras reutilizables sin perder el tipado fuerte.\r\ninterface ApiResponse<T> {\r\ndata: T | null;\r\nstatus: number;\r\nerror?: string;\r\n}\r\nconst userResponse: ApiResponse<{ id: number; name: string }> = { // 'T' i\r\nn this case is an object with 'id' and 'name'\r\n\r\n‚úÖ\r\n\r\ndata: { id: 1, name: \"Alice\" }, //\r\nUser data retrieved successfully\r\nstatus: 200\r\n//\r\nSuccessful HTTP status code\r\n\r\n‚úÖ\r\n\r\n};\r\n\r\nconst errorResponse: ApiResponse<null> = { // 'T' in this case is null\r\n\r\n‚ùå No data available\r\n// ‚ùå Status code indicating 'Not Found'\r\nerror: \"User not found\" // ‚úÖ Error message\r\ndata: null,\r\nstatus: 404,\r\n\r\n};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":159,"to":207}}}}],["22",{"pageContent":"};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {\r\ndata: T | null; // Holds the response data or null if there's an error\r\nstatus: number;\r\nerror?: string;\r\n}\r\n//\r\n\r\nüìå Generic function to fetch data from an API\r\n\r\nasync function fetchData<T>(url: string): Promise<ApiResponse<T>> {\r\n\r\nTypescript typing Guide\r\n\r\n5\r\n\r\n\ftry {\r\nconst response = await fetch(url);\r\n// Check if the response is not successful\r\nif (!response.ok) {\r\nreturn { data: null, status: response.status, error: response.statusTex\r\nt };\r\n}\r\n// Parse and return the JSON response\r\nconst data: T = await response.json();\r\nreturn { data, status: response.status };\r\n} catch (error) {\r\n// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":196,"to":239}}}}],["23",{"pageContent":"// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown\r\nany: Permite cualquier tipo sin restricciones, deshabilitando la seguridad de\r\ntipos.\r\nunknown: Acepta cualquier tipo, pero requiere validaci√≥n antes de su uso.\r\n\r\nCu√°ndo usar any\r\nA pesar de que unknown es generalmente m√°s seguro, existen situaciones\r\nespec√≠ficas donde any puede ser apropiado:\r\nMigraciones graduales: Cuando se migra c√≥digo JavaScript a TypeScript\r\nde forma incremental.\r\nIntegraciones con bibliotecas externas: Al trabajar con bibliotecas sin\r\ndefiniciones de tipos.\r\nPrototipos r√°pidos: En fases iniciales de desarrollo donde la prioridad es la\r\nvelocidad.\r\n\r\nTypescript typing Guide\r\n\r\n6\r\n\r\n\fDatos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":233,"to":264}}}}],["24",{"pageContent":"Datos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime\r\n\r\n‚úÖ Se permite sin validaci√≥n, puede causar error\r\n\r\nEjemplo con unknown (Recomendado)\r\nEl tipo unknown debe ser la opci√≥n predeterminada cuando se necesita\r\nflexibilidad de tipos:\r\nlet value: unknown;\r\nvalue = \"Texto\";\r\nvalue = 42;\r\nif (typeof value === \"string\") {\r\nlet str: string = value; //\r\nSolo se permite tras validaci√≥n\r\n}\r\n\r\n‚úÖ\r\n\r\n6. Tipos Avanzados\r\nTipos Condicionales\r\nPermiten evaluar un tipo en tiempo de compilaci√≥n.\r\ntype IsString<T> = T extends string ? \"Yes\" : \"No\";\r\ntype Result = IsString<number>; // \"No\"\r\n\r\nInferencia de Tipos\r\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":258,"to":297}}}}],["25",{"pageContent":"function getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude\r\nRecord<K, V> : Permite definir un objeto donde las claves (K) tienen un tipo\r\n\r\nespec√≠fico y los valores (V) siguen una estructura determinada.\r\ntype Users = Record<string, { id: number; name: string }>;\r\nconst users: Users = {\r\nuser1: { id: 1, name: \"Alice\" },\r\nuser2: { id: 2, name: \"Bob\" }\r\n};\r\nOmit<T, K> :\r\n\r\nElimina propiedades espec√≠ficas de un tipo.\r\n\r\ntype User = { id: number; name: string; email: string };\r\ntype UserWithoutEmail = Omit<User, \"email\">;\r\nExclude<T, U> : Elimina tipos de una uni√≥n.\r\n\r\ntype Status = \"active\" | \"inactive\" | \"banned\";\r\ntype ActiveStatus = Exclude<Status, \"banned\">;\r\n\r\nTipos Utilitarios Mapeados\r\nSe usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":288,"to":323}}}}],["26",{"pageContent":"Se usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type\r\ntype User = {\r\nid: number;\r\nname: string;\r\n};\r\ntype ReadonlyUser = ReadonlyWrapper<User>;\r\n// Equivalente a:\r\n\r\nTypescript typing Guide\r\n\r\n8\r\n\r\n\f// type ReadonlyUser = { readonly id: number; readonly name: string; }\r\nconst user: ReadonlyUser = { id: 1, name: \"Juan\" };\r\nuser.name = \"Pedro\"; //\r\ndonly\r\n\r\n‚ùå Error: No se puede modificar una propiedad rea\r\n\r\nReadonly, Partial, Required y Pick\r\nEstos tipos utilitarios permiten manipular las propiedades de un objeto:\r\ntype User = {\r\nid: number;\r\nname: string;\r\nemail?: string;\r\n};\r\nReadonly<T> : Convierte todas las propiedades en solo lectura.\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\nPartial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":318,"to":355}}}}],["27",{"pageContent":"Partial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.\r\n\r\ntype RequiredUser = Required<User>;\r\nPick<T, K> : Selecciona propiedades espec√≠ficas de un tipo.\r\n\r\ntype UserIdAndName = Pick<User, \"id\" | \"name\">;\r\nPara ampliar la informacion sobre otros utility types pueden visitar la\r\ndocumentacion oficial https://www.typescriptlang.org/docs/handbook/utilitytypes.html\r\n\r\nTypescript typing Guide\r\n\r\n9\r\n\r\n\f8. Uso de Enum en TypeScript\r\nDefinici√≥n de Enum\r\nUn enum es un tipo especial en TypeScript que permite definir un conjunto de\r\nconstantes con nombre.\r\n\r\nTipos de Enum\r\nEnum Num√©rico\r\nPor defecto, los enums asignan valores num√©ricos comenzando desde 0:\r\nenum Direction {\r\nUp, // 0\r\nDown, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":352,"to":386}}}}],["28",{"pageContent":"Down, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:\r\nenum Direction {\r\nUp = 1,\r\nDown, // 2\r\nLeft, // 3\r\nRight // 4\r\n}\r\n\r\nEnum de Cadenas\r\nenum UserRole {\r\nAdmin = \"ADMIN\",\r\nUser = \"USER\",\r\nGuest = \"GUEST\"\r\n\r\nTypescript typing Guide\r\n\r\n10\r\n\r\n\f}\r\n// No hay reverse mapping en enums de cadenas\r\nconsole.log(UserRole.Admin); // \"ADMIN\"\r\n\r\nCaracter√≠stica de Reverse Mapping\r\nLos enums num√©ricos generan un mapa bidireccional (nombre a valor y valor a\r\nnombre):\r\nenum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconsole.log(Direction[2]); // \"Down\"\r\nEsto aumenta el tama√±o del c√≥digo generado, ya que se crea un objeto m√°s\r\ncomplejo.\r\n\r\nEnums Const\r\nLos const enum se eliminan completamente durante la compilaci√≥n,\r\nreemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":378,"to":427}}}}],["29",{"pageContent":"reemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconst dir = Direction.Up; // Se compila a: const dir = 1;\r\n\r\nEjemplo Pr√°ctico\r\n\r\nTypescript typing Guide\r\n\r\n11\r\n\r\n\fCaso de uso: Definir roles de usuario en una aplicaci√≥n.\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Full access\";\r\n}\r\nreturn \"Limited access\";\r\n}\r\n\r\n9. Enum vs Tipos literales\r\nUsar enum cuando:\r\nSe requiere una representaci√≥n en tiempo de ejecuci√≥n\r\nexiste en JavaScript despu√©s de la compilaci√≥n, lo que permite\r\nacceder a sus valores en tiempo de ejecuci√≥n.\r\nenum\r\n\r\n√ötil si necesitas valores asignados autom√°ticamente o bidireccionales\r\n(clave-valor y valor-clave).\r\nLos valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":423,"to":459}}}}],["30",{"pageContent":"Los valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos\r\nSi necesitas asignar valores personalizados, como cadenas o n√∫meros\r\nespec√≠ficos.\r\n\r\nEjemplo de enum\r\nenum UserRole {\r\nAdmin = \"admin\",\r\nUser = \"user\",\r\nGuest = \"guest\"\r\n}\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Acceso total\";\r\n\r\nTypescript typing Guide\r\n\r\n12\r\n\r\n\f}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(UserRole.Admin)); // \"Acceso total\"\r\n\r\nUsar type con uniones literales cuando:\r\nNo se necesita una representaci√≥n en tiempo de ejecuci√≥n\r\ndesaparece despu√©s de la compilaci√≥n, mejorando el rendimiento\r\ny reduciendo el tama√±o del c√≥digo.\r\ntype\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":456,"to":490}}}}],["31",{"pageContent":"type\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada\r\nSi solo necesitas definir un conjunto de valores sin m√©todos\r\nadicionales.\r\n\r\nEjemplo de type con uniones literales\r\ntype UserRole = \"admin\" | \"user\" | \"guest\";\r\nfunction getPermissions(role: UserRole) {\r\nif (role === \"admin\") {\r\nreturn \"Acceso total\";\r\n}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(\"admin\")); // \"Acceso total\"\r\n\r\n10. Recursos Adicionales\r\nhttps://www.typescriptlang.org/docs/handbook/intro.html\r\n\r\nTypescript typing Guide\r\n\r\n13\r\n\r\n\fhttps://docs.aws.amazon.com/prescriptive-guidance/latest/best-practicescdk-typescript-iac/typescript-best-practices.html\r\nhttps://basarat.gitbook.io/typescript/type-system\r\nIv√°n Santander\r\n\r\nTypescript typing Guide\r\n\r\n14\r\n\r\n\f\r\n\r\n\r\nGuia Escrita por Ivan Santander","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":486,"to":522}}}}],["32",{"pageContent":"Typescript typing Guide\r\n1. Introducci√≥n\r\nObjetivo del Documento\r\nExplicar la importancia del tipado en TypeScript y establecer lineamientos\r\nclaros sobre el uso de interface, type, any, unknown y gen√©ricos, adem√°s de\r\nlos tipos avanzados y enum, dentro del equipo de desarrollo en LearUp.\r\n\r\nBeneficios del Tipado\r\nMejora de la seguridad del c√≥digo.\r\nDetecci√≥n temprana de errores.\r\nMejor documentaci√≥n y autocompletado en IDEs.\r\n\r\n2. Uso de Interfaces\r\nDefinici√≥n de Interfaces\r\nUna interface se usa para definir la estructura de un objeto de manera clara y\r\nextensible. Se recomienda para estructuras que puedan evolucionar con el\r\ntiempo y ser extendidas.\r\n\r\nSintaxis B√°sica\r\ninterface User {\r\nid: number;\r\nname: string;\r\nemail: string;\r\n}\r\n\r\nExtensi√≥n de Interfaces\r\nPermite heredar propiedades de otras interfaces, facilitando la reutilizaci√≥n del\r\nc√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":1,"to":38}}}}],["33",{"pageContent":"c√≥digo.\r\n\r\nTypescript typing Guide\r\n\r\n1\r\n\r\n\finterface Person {\r\nid: number;\r\nname: string;\r\n}\r\ninterface Employee extends Person {\r\nposition: string;\r\n}\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Modelado de datos de usuario en una API.\r\nfunction getUser(): User {\r\nreturn { id: 1, name: \"John Doe\", email: \"john@company.com\" };\r\n}\r\n\r\n3. Uso de Types\r\nDefinici√≥n de Types\r\nUn type permite definir valores basados en los tipos primitivos de TypeScript:\r\n\r\nTipos B√°sicos\r\n// Primitive Types\r\ntype Text = string;\r\n// Text strings\r\ntype Age = number;\r\n// Numbers (integers or decimals)\r\ntype IsActive = boolean; // True or false values\r\ntype CreatedAt = Date; // Dates and times\r\ntype UniqueID = symbol; // Unique identifiers\r\ntype AnyValue = any; // Any type (avoid using it)\r\ntype UnknownValue = unknown; // Any type, but safer than 'any'\r\ntype Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":28,"to":68}}}}],["34",{"pageContent":"type Nothing = void; // Functions with no return value\r\ntype NeverHappens = never; // Value that never occurs\r\n\r\nTypescript typing Guide\r\n\r\n2\r\n\r\n\fstring / number / boolean: Datos b√°sicos como nombres, edades o\r\nestados.\r\nDate ‚Üí Fechas en APIs o registros.\r\nsymbol ‚Üí Identificadores √∫nicos en estructuras avanzadas.\r\nvoid / never ‚Üí Definir funciones con retorno vac√≠o o errores.\r\nany / unknown ‚Üí Casos donde el tipo es incierto (se recomienda unknown\r\nsobre any).\r\n\r\nTipos de Uni√≥n e Intersecci√≥n\r\nUni√≥n (|): Permite m√∫ltiples tipos posibles.\r\nIntersecci√≥n (&): Combina m√∫ltiples tipos en uno solo\r\n\r\nüìå\r\n\r\n//\r\nUnion: A value can be one type or another\r\ntype ID = string | number;\r\ntype Status = \"active\" | \"inactive\" | \"pending\";\r\nlet userId: ID = 123;\r\nuserId = \"abc123\"; //\r\n\r\n‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":63,"to":101}}}}],["35",{"pageContent":"‚úÖ Correct, as it can be a string or a number\r\n\r\nlet accountStatus: Status = \"active\";\r\naccountStatus = \"suspended\"; //\r\nError: \"suspended\" is not a valid value\r\n\r\nüìå\r\n\r\n‚ùå\r\n\r\n//\r\nIntersection: Combines multiple types into one\r\ntype User = { id: number; name: string };\r\ntype Employee = User & { position: string; salary: number };\r\nconst employee: Employee = {\r\nid: 1,\r\nname: \"Alice\",\r\nposition: \"Developer\",\r\nsalary: 50000\r\n};\r\n//\r\n\r\n‚ùå Error if a property is missing (e.g., position or salary)\r\n\r\nTypescript typing Guide\r\n\r\n3\r\n\r\n\fTipos Literales\r\nRestringen un valor a un conjunto espec√≠fico.\r\ntype Role = \"admin\" | \"user\" | \"guest\"; // Can only be one of these values\r\n\r\nTipos de Funciones\r\nDefinen la firma de una funci√≥n, asegurando los tipos de sus par√°metros y\r\nrespuesta.\r\n// Define a function type\r\ntype MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":91,"to":130}}}}],["36",{"pageContent":"type MathOperation = (a: number, b: number) => number;\r\n// Functions that match the signature\r\nconst sum: MathOperation = (x, y) => x + y;\r\nconst multiply: MathOperation = (x, y) => x * y;\r\n\r\n‚û°Ô∏è 8\r\n‚û°Ô∏è 15\r\n\r\nconsole.log(sum(5, 3));\r\n//\r\nconsole.log(multiply(5, 3)); //\r\n\r\n4. Uso de Tipos Gen√©ricos\r\nDefinici√≥n de Tipos Gen√©ricos\r\nLos tipos gen√©ricos permiten crear estructuras reutilizables que trabajan con\r\ntipos din√°micos en lugar de un tipo fijo. Esto los hace flexibles y escalables.\r\n\r\nSintaxis basica de Gen√©ricos\r\nfunction identity<T>(arg: T): T {\r\nreturn arg;\r\n}\r\n\r\n‚û°Ô∏è 10 (type: number)\r\nconsole.log(identity(\"Hola\")); // ‚û°Ô∏è \"Hola\" (type: string)\r\nconsole.log(identity(10));\r\n\r\nT\r\n\r\n//\r\n\r\nes un par√°metro de tipo que representa un tipo din√°mico.\r\n\r\nTypescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":127,"to":166}}}}],["37",{"pageContent":"Typescript typing Guide\r\n\r\n4\r\n\r\n\fSe resuelve autom√°ticamente seg√∫n el valor pasado.\r\n\r\nUso de gen√©ricos en interfaces\r\nEn interfaces tambi√©n pueden usar gen√©ricos, lo que permite definir\r\nestructuras reutilizables sin perder el tipado fuerte.\r\ninterface ApiResponse<T> {\r\ndata: T | null;\r\nstatus: number;\r\nerror?: string;\r\n}\r\nconst userResponse: ApiResponse<{ id: number; name: string }> = { // 'T' i\r\nn this case is an object with 'id' and 'name'\r\n\r\n‚úÖ\r\n\r\ndata: { id: 1, name: \"Alice\" }, //\r\nUser data retrieved successfully\r\nstatus: 200\r\n//\r\nSuccessful HTTP status code\r\n\r\n‚úÖ\r\n\r\n};\r\n\r\nconst errorResponse: ApiResponse<null> = { // 'T' in this case is null\r\n\r\n‚ùå No data available\r\n// ‚ùå Status code indicating 'Not Found'\r\nerror: \"User not found\" // ‚úÖ Error message\r\ndata: null,\r\nstatus: 404,\r\n\r\n};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":159,"to":207}}}}],["38",{"pageContent":"};\r\n\r\n//\r\n\r\nEjemplo Pr√°ctico\r\nCaso de uso: Creaci√≥n de una funci√≥n gen√©rica para manejar respuestas de\r\nAPI.\r\n//\r\n\r\nüìå Generic interface for API responses\r\n\r\ninterface ApiResponse<T> {\r\ndata: T | null; // Holds the response data or null if there's an error\r\nstatus: number;\r\nerror?: string;\r\n}\r\n//\r\n\r\nüìå Generic function to fetch data from an API\r\n\r\nasync function fetchData<T>(url: string): Promise<ApiResponse<T>> {\r\n\r\nTypescript typing Guide\r\n\r\n5\r\n\r\n\ftry {\r\nconst response = await fetch(url);\r\n// Check if the response is not successful\r\nif (!response.ok) {\r\nreturn { data: null, status: response.status, error: response.statusTex\r\nt };\r\n}\r\n// Parse and return the JSON response\r\nconst data: T = await response.json();\r\nreturn { data, status: response.status };\r\n} catch (error) {\r\n// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":196,"to":239}}}}],["39",{"pageContent":"// Handle network or unexpected errors\r\nreturn { data: null, status: 500, error: (error as Error).message };\r\n}\r\n}\r\n\r\n5. Tipos Especiales: any vs unknown\r\nDiferencias entre any y unknown\r\nany: Permite cualquier tipo sin restricciones, deshabilitando la seguridad de\r\ntipos.\r\nunknown: Acepta cualquier tipo, pero requiere validaci√≥n antes de su uso.\r\n\r\nCu√°ndo usar any\r\nA pesar de que unknown es generalmente m√°s seguro, existen situaciones\r\nespec√≠ficas donde any puede ser apropiado:\r\nMigraciones graduales: Cuando se migra c√≥digo JavaScript a TypeScript\r\nde forma incremental.\r\nIntegraciones con bibliotecas externas: Al trabajar con bibliotecas sin\r\ndefiniciones de tipos.\r\nPrototipos r√°pidos: En fases iniciales de desarrollo donde la prioridad es la\r\nvelocidad.\r\n\r\nTypescript typing Guide\r\n\r\n6\r\n\r\n\fDatos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":233,"to":264}}}}],["40",{"pageContent":"Datos con estructura impredecible: Al recibir datos cuya estructura puede\r\nvariar significativamente.\r\nlet data: any;\r\ndata = \"Texto\";\r\ndata = 42;\r\nlet result: string = data; //\r\nes en runtime\r\n\r\n‚úÖ Se permite sin validaci√≥n, puede causar error\r\n\r\nEjemplo con unknown (Recomendado)\r\nEl tipo unknown debe ser la opci√≥n predeterminada cuando se necesita\r\nflexibilidad de tipos:\r\nlet value: unknown;\r\nvalue = \"Texto\";\r\nvalue = 42;\r\nif (typeof value === \"string\") {\r\nlet str: string = value; //\r\nSolo se permite tras validaci√≥n\r\n}\r\n\r\n‚úÖ\r\n\r\n6. Tipos Avanzados\r\nTipos Condicionales\r\nPermiten evaluar un tipo en tiempo de compilaci√≥n.\r\ntype IsString<T> = T extends string ? \"Yes\" : \"No\";\r\ntype Result = IsString<number>; // \"No\"\r\n\r\nInferencia de Tipos\r\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":258,"to":297}}}}],["41",{"pageContent":"function getProperty<T, K extends keyof T>(obj: T, key: K) {\r\nreturn obj[key];\r\n}\r\n\r\nTypescript typing Guide\r\n\r\n7\r\n\r\n\fTipos Utilitarios Comunes en TypeScript: Record Omit y\r\nExclude\r\nRecord<K, V> : Permite definir un objeto donde las claves (K) tienen un tipo\r\n\r\nespec√≠fico y los valores (V) siguen una estructura determinada.\r\ntype Users = Record<string, { id: number; name: string }>;\r\nconst users: Users = {\r\nuser1: { id: 1, name: \"Alice\" },\r\nuser2: { id: 2, name: \"Bob\" }\r\n};\r\nOmit<T, K> :\r\n\r\nElimina propiedades espec√≠ficas de un tipo.\r\n\r\ntype User = { id: number; name: string; email: string };\r\ntype UserWithoutEmail = Omit<User, \"email\">;\r\nExclude<T, U> : Elimina tipos de una uni√≥n.\r\n\r\ntype Status = \"active\" | \"inactive\" | \"banned\";\r\ntype ActiveStatus = Exclude<Status, \"banned\">;\r\n\r\nTipos Utilitarios Mapeados\r\nSe usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":288,"to":323}}}}],["42",{"pageContent":"Se usan para transformar las propiedades de un tipo existente.\r\n// Ejemplo con geneticos\r\ntype ReadonlyWrapper<T> = {\r\nreadonly [K in keyof T]: T[K];\r\n};\r\n// Ejemplo con type\r\ntype User = {\r\nid: number;\r\nname: string;\r\n};\r\ntype ReadonlyUser = ReadonlyWrapper<User>;\r\n// Equivalente a:\r\n\r\nTypescript typing Guide\r\n\r\n8\r\n\r\n\f// type ReadonlyUser = { readonly id: number; readonly name: string; }\r\nconst user: ReadonlyUser = { id: 1, name: \"Juan\" };\r\nuser.name = \"Pedro\"; //\r\ndonly\r\n\r\n‚ùå Error: No se puede modificar una propiedad rea\r\n\r\nReadonly, Partial, Required y Pick\r\nEstos tipos utilitarios permiten manipular las propiedades de un objeto:\r\ntype User = {\r\nid: number;\r\nname: string;\r\nemail?: string;\r\n};\r\nReadonly<T> : Convierte todas las propiedades en solo lectura.\r\n\r\ntype ReadonlyUser = Readonly<User>;\r\nPartial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":318,"to":355}}}}],["43",{"pageContent":"Partial<T> : Hace que todas las propiedades sean opcionales.\r\n\r\ntype PartialUser = Partial<User>;\r\nRequired<T> : Hace que todas las propiedades sean requeridas.\r\n\r\ntype RequiredUser = Required<User>;\r\nPick<T, K> : Selecciona propiedades espec√≠ficas de un tipo.\r\n\r\ntype UserIdAndName = Pick<User, \"id\" | \"name\">;\r\nPara ampliar la informacion sobre otros utility types pueden visitar la\r\ndocumentacion oficial https://www.typescriptlang.org/docs/handbook/utilitytypes.html\r\n\r\nTypescript typing Guide\r\n\r\n9\r\n\r\n\f8. Uso de Enum en TypeScript\r\nDefinici√≥n de Enum\r\nUn enum es un tipo especial en TypeScript que permite definir un conjunto de\r\nconstantes con nombre.\r\n\r\nTipos de Enum\r\nEnum Num√©rico\r\nPor defecto, los enums asignan valores num√©ricos comenzando desde 0:\r\nenum Direction {\r\nUp, // 0\r\nDown, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":352,"to":386}}}}],["44",{"pageContent":"Down, // 1\r\nLeft, // 2\r\nRight // 3\r\n}\r\nconsole.log(Direction.Up); // 0\r\nconsole.log(Direction[0]); // \"Up\" (reverse mapping)\r\n\r\nEnum con Valores Inicializados\r\nSe pueden asignar valores espec√≠ficos:\r\nenum Direction {\r\nUp = 1,\r\nDown, // 2\r\nLeft, // 3\r\nRight // 4\r\n}\r\n\r\nEnum de Cadenas\r\nenum UserRole {\r\nAdmin = \"ADMIN\",\r\nUser = \"USER\",\r\nGuest = \"GUEST\"\r\n\r\nTypescript typing Guide\r\n\r\n10\r\n\r\n\f}\r\n// No hay reverse mapping en enums de cadenas\r\nconsole.log(UserRole.Admin); // \"ADMIN\"\r\n\r\nCaracter√≠stica de Reverse Mapping\r\nLos enums num√©ricos generan un mapa bidireccional (nombre a valor y valor a\r\nnombre):\r\nenum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconsole.log(Direction[2]); // \"Down\"\r\nEsto aumenta el tama√±o del c√≥digo generado, ya que se crea un objeto m√°s\r\ncomplejo.\r\n\r\nEnums Const\r\nLos const enum se eliminan completamente durante la compilaci√≥n,\r\nreemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":378,"to":427}}}}],["45",{"pageContent":"reemplazando sus referencias con valores literales, lo que resulta en un c√≥digo\r\nm√°s eficiente:\r\nconst enum Direction {\r\nUp = 1,\r\nDown,\r\nLeft,\r\nRight\r\n}\r\nconst dir = Direction.Up; // Se compila a: const dir = 1;\r\n\r\nEjemplo Pr√°ctico\r\n\r\nTypescript typing Guide\r\n\r\n11\r\n\r\n\fCaso de uso: Definir roles de usuario en una aplicaci√≥n.\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Full access\";\r\n}\r\nreturn \"Limited access\";\r\n}\r\n\r\n9. Enum vs Tipos literales\r\nUsar enum cuando:\r\nSe requiere una representaci√≥n en tiempo de ejecuci√≥n\r\nexiste en JavaScript despu√©s de la compilaci√≥n, lo que permite\r\nacceder a sus valores en tiempo de ejecuci√≥n.\r\nenum\r\n\r\n√ötil si necesitas valores asignados autom√°ticamente o bidireccionales\r\n(clave-valor y valor-clave).\r\nLos valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":423,"to":459}}}}],["46",{"pageContent":"Los valores son usados en m√∫ltiples archivos o m√≥dulos\r\nSi los valores deben ser reutilizables en varios lugares, los enum pueden\r\nser m√°s convenientes.\r\nTrabajas con valores din√°micos\r\nSi necesitas asignar valores personalizados, como cadenas o n√∫meros\r\nespec√≠ficos.\r\n\r\nEjemplo de enum\r\nenum UserRole {\r\nAdmin = \"admin\",\r\nUser = \"user\",\r\nGuest = \"guest\"\r\n}\r\nfunction getPermissions(role: UserRole) {\r\nif (role === UserRole.Admin) {\r\nreturn \"Acceso total\";\r\n\r\nTypescript typing Guide\r\n\r\n12\r\n\r\n\f}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(UserRole.Admin)); // \"Acceso total\"\r\n\r\nUsar type con uniones literales cuando:\r\nNo se necesita una representaci√≥n en tiempo de ejecuci√≥n\r\ndesaparece despu√©s de la compilaci√≥n, mejorando el rendimiento\r\ny reduciendo el tama√±o del c√≥digo.\r\ntype\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":456,"to":490}}}}],["47",{"pageContent":"type\r\n\r\nSe busca mejor compatibilidad con inferencia de tipos\r\nTypeScript puede inferir valores m√°s f√°cilmente con uniones literales.\r\nLos valores no necesitan l√≥gica asociada\r\nSi solo necesitas definir un conjunto de valores sin m√©todos\r\nadicionales.\r\n\r\nEjemplo de type con uniones literales\r\ntype UserRole = \"admin\" | \"user\" | \"guest\";\r\nfunction getPermissions(role: UserRole) {\r\nif (role === \"admin\") {\r\nreturn \"Acceso total\";\r\n}\r\nreturn \"Acceso limitado\";\r\n}\r\nconsole.log(getPermissions(\"admin\")); // \"Acceso total\"\r\n\r\n10. Recursos Adicionales\r\nhttps://www.typescriptlang.org/docs/handbook/intro.html\r\n\r\nTypescript typing Guide\r\n\r\n13\r\n\r\n\fhttps://docs.aws.amazon.com/prescriptive-guidance/latest/best-practicescdk-typescript-iac/typescript-best-practices.html\r\nhttps://basarat.gitbook.io/typescript/type-system\r\nIv√°n Santander\r\n\r\nTypescript typing Guide\r\n\r\n14\r\n\r\n\f\r\n\r\n\r\nGuia Escrita por Ivan Santander","metadata":{"source":"docs\\Typescript_typing_Guide.txt","loc":{"lines":{"from":486,"to":522}}}}]]