[["0",{"pageContent":"Análisis y Recomendaciones para la Gestión de Permisos\r\nJerárquicos en un Sistema de Gestión Documental\r\n1.​ Introducción:​\r\n\r\nLa gestión de permisos robusta y escalable en sistemas de gestión documental\r\nes fundamental para garantizar la seguridad de los datos y el cumplimiento\r\nnormativo. La introducción de permisos jerárquicos añade una capa de\r\ncomplejidad, requiriendo una consideración cuidadosa de la herencia y los\r\ndiferentes niveles de acceso. Una estructura de base de datos eficiente es\r\nesencial para asegurar el rendimiento, la escalabilidad y la mantenibilidad de la\r\ngestión de permisos y las funcionalidades de compartición. Esquemas mal\r\ndiseñados pueden conducir a consultas complejas, rendimiento lento y posibles\r\nvulnerabilidades de seguridad. El presente informe tiene como objetivo analizar\r\ncríticamente la estructura de base de datos actual, evaluar su idoneidad para los\r\nrequisitos especificados y proporcionar una recomendación bien justificada","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":1,"to":15}}}}],["1",{"pageContent":"críticamente la estructura de base de datos actual, evaluar su idoneidad para los\r\nrequisitos especificados y proporcionar una recomendación bien justificada\r\nsobre el enfoque óptimo, incluyendo una guía práctica para su implementación.\r\n2.​ Análisis Crítico de la Estructura Actual de la Base de Datos:​\r\nEl esquema actual de la base de datos consta de las tablas DocumentDMS,\r\nFolderDMS, EffectivePermission, Share y AccessLevel, cuyas relaciones son\r\ncruciales para comprender la gestión de permisos. Es fundamental entender las\r\ncolumnas de cada tabla y las relaciones que existen entre ellas, como las claves\r\nforáneas. La forma en que se relacionan los documentos y las carpetas, y si\r\nexiste una relación auto-referencial en FolderDMS para representar la jerarquía,\r\nson aspectos importantes a considerar. También es necesario analizar cómo se\r\nvinculan los permisos a los usuarios, documentos o carpetas y los niveles de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":14,"to":25}}}}],["2",{"pageContent":"son aspectos importantes a considerar. También es necesario analizar cómo se\r\nvinculan los permisos a los usuarios, documentos o carpetas y los niveles de\r\nacceso, así como el papel de la tabla Share en la concesión de acceso a otros\r\nusuarios. La presencia de la tabla EffectivePermission sugiere un cálculo previo o\r\nmaterialización de los permisos, por lo que es necesario comprender cómo se\r\npuebla y se mantiene esta tabla.​\r\nLas estrategias para la organización de archivos y carpetas a nivel de sistema de\r\narchivos enfatizan la importancia de las estructuras jerárquicas y las\r\nconvenciones de nomenclatura consistentes.1 Es probable que estas\r\nconsideraciones se reflejen en las tablas FolderDMS y DocumentDMS, aunque no\r\ndetallan directamente el aspecto de los permisos. Sistemas de gestión\r\ndocumental eficaces deben ofrecer control de acceso y privilegios de edición 7, lo\r\nque sugiere que el esquema actual probablemente tiene como objetivo soportar","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":24,"to":36}}}}],["3",{"pageContent":"documental eficaces deben ofrecer control de acceso y privilegios de edición 7, lo\r\nque sugiere que el esquema actual probablemente tiene como objetivo soportar\r\nestas funcionalidades. La tabla 1 presenta una posible estructura para el\r\nesquema actual de la base de datos, aunque la estructura real puede variar.\r\n\r\n\fTabla\r\n\r\nColumna\r\n\r\nTipo de\r\nDatos\r\n\r\nClave\r\nPrimaria\r\n\r\nDocumentD\r\nMS\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre del\r\ndocumento\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos del\r\ndocumento\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nparent_folde\r\nr_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre de\r\nla carpeta\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos de\r\nla carpeta\r\n\r\neffective_per\r\nmission_id\r\n\r\nINTEGER\r\n\r\nFolderDMS\r\n\r\nEffectivePer\r\nmission\r\n\r\nClave\r\nForánea\r\n\r\nIdentificador\r\núnico del\r\ndocumento\r\nSí\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\nque contiene\r\nel\r\ndocumento\r\nen\r\nFolderDMS\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\nSí (a sí\r\nmismo)\r\n\r\nSí\r\n\r\nDescripción\r\n\r\nReferencia a","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":35,"to":140}}}}],["4",{"pageContent":"único del\r\ndocumento\r\nSí\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\nque contiene\r\nel\r\ndocumento\r\nen\r\nFolderDMS\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\nSí (a sí\r\nmismo)\r\n\r\nSí\r\n\r\nDescripción\r\n\r\nReferencia a\r\nla carpeta\r\npadre en\r\nFolderDMS\r\n(para la\r\njerarquía)\r\n\r\nIdentificador\r\núnico del\r\npermiso\r\n\r\n\fefectivo\r\n\r\nShare\r\n\r\nuser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\ndocumento\r\nen\r\nDocumentD\r\nMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta en\r\nFolderDMS\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\nnivel de\r\nacceso en\r\nAccessLevel\r\n(ej., lectura,\r\nescritura)\r\n\r\n...\r\n\r\n...\r\n\r\nshare_id\r\n\r\nINTEGER\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\ndocumento\r\ncompartido\r\nen\r\nDocumentD\r\nMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\ncompartida\r\nen\r\n\r\nOtros\r\natributos del\r\npermiso\r\nefectivo\r\nSí\r\n\r\nIdentificador\r\núnico del\r\nrecurso\r\ncompartido\r\n\r\n\fFolderDMS\r\n\r\nAccessLevel\r\n\r\nshared_with_\r\nuser_id\r\n\r\nINTEGER","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":116,"to":248}}}}],["5",{"pageContent":"la carpeta\r\ncompartida\r\nen\r\n\r\nOtros\r\natributos del\r\npermiso\r\nefectivo\r\nSí\r\n\r\nIdentificador\r\núnico del\r\nrecurso\r\ncompartido\r\n\r\n\fFolderDMS\r\n\r\nAccessLevel\r\n\r\nshared_with_\r\nuser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario con\r\nel que se\r\ncomparte\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nshared_by_u\r\nser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario que\r\ncompartió el\r\nrecurso\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos del\r\nrecurso\r\ncompartido\r\n(ej., fecha de\r\ncompartición\r\n)\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre del\r\nnivel de\r\nacceso (ej.,\r\nLectura,\r\nEscritura,\r\nEdición)\r\n\r\npermissions_\r\nmask\r\n\r\nINTEGER\r\n\r\nMáscara de\r\nbits o valor\r\nque\r\nrepresenta\r\n\r\nSí\r\n\r\nSí\r\n\r\nReferencia al\r\nnivel de\r\nacceso para\r\nel recurso\r\ncompartido\r\nen\r\nAccessLevel\r\n\r\nIdentificador\r\núnico del\r\nnivel de\r\nacceso\r\n\r\n\flos permisos\r\nespecíficos\r\nasociados a\r\neste nivel de\r\nacceso\r\n\r\nLa idoneidad de la estructura actual para representar permisos jerárquicos multinivel","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":226,"to":331}}}}],["6",{"pageContent":"Identificador\r\núnico del\r\nnivel de\r\nacceso\r\n\r\n\flos permisos\r\nespecíficos\r\nasociados a\r\neste nivel de\r\nacceso\r\n\r\nLa idoneidad de la estructura actual para representar permisos jerárquicos multinivel\r\ndepende de cómo se gestiona la relación `parent_folder_id` en `FolderDMS` y cómo\r\nse utiliza la tabla `EffectivePermission` para aplicar estos permisos a través de la\r\njerarquía. La herencia de permisos, donde los permisos establecidos en una carpeta\r\nse propagan a sus subcarpetas y documentos, es un requisito fundamental.[9] La\r\nestructura actual debe implementar un mecanismo similar, posiblemente a través de\r\nla tabla `EffectivePermission` o mediante lógica de aplicación que consulte las\r\nrelaciones entre carpetas. La gestión de diferentes niveles de acceso (por ejemplo,\r\nlectura, escritura, eliminación) probablemente se maneja mediante la tabla\r\n`AccessLevel` y su columna `permissions_mask`, que permite definir granularmente\r\nlas acciones permitidas para cada nivel.​\r\n​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":320,"to":342}}}}],["7",{"pageContent":"`AccessLevel` y su columna `permissions_mask`, que permite definir granularmente\r\nlas acciones permitidas para cada nivel.​\r\n​\r\nSin embargo, la estructura actual podría presentar limitaciones para implementar\r\neficientemente la herencia de permisos a través de una jerarquía profunda de\r\ndocumentos y carpetas. Si `FolderDMS` utiliza un modelo de lista de adyacencia\r\n(donde cada carpeta simplemente apunta a su padre), la consulta de los permisos\r\nefectivos para un usuario en un elemento específico, considerando la herencia, podría\r\nrequerir consultas recursivas o múltiples uniones, lo que puede ser ineficiente para\r\njerarquías muy anidadas.[10, 11] Mantener la tabla `EffectivePermission` consistente\r\ncon los cambios en la jerarquía o los permisos explícitos también podría ser complejo\r\ny consumir muchos recursos, requiriendo la implementación de triggers o trabajos por\r\nlotes para asegurar la integridad de los datos. Además, es importante considerar","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":340,"to":352}}}}],["8",{"pageContent":"y consumir muchos recursos, requiriendo la implementación de triggers o trabajos por\r\nlotes para asegurar la integridad de los datos. Además, es importante considerar\r\ncómo la estructura actual maneja las excepciones a los permisos heredados en\r\nniveles inferiores de la jerarquía.​\r\n​\r\nLa funcionalidad \"Compartido conmigo\" probablemente se implementa a través de la\r\ntabla `Share`, que registra los elementos que se han compartido con usuarios\r\nespecíficos. Esta tabla probablemente contiene referencias al documento o carpeta\r\ncompartida, al usuario con el que se comparte, al usuario que compartió el elemento\r\ny al nivel de acceso otorgado.[12, 13] La eficiencia de la consulta para obtener todos\r\n\r\n\flos elementos compartidos con un usuario dependerá de la indexación y la estructura\r\nde la tabla `Share`, así como de las uniones necesarias con `DocumentDMS` y\r\n`FolderDMS`. Es posible que la estructura actual trate los elementos compartidos de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":351,"to":364}}}}],["9",{"pageContent":"de la tabla `Share`, así como de las uniones necesarias con `DocumentDMS` y\r\n`FolderDMS`. Es posible que la estructura actual trate los elementos compartidos de\r\nmanera diferente a los elementos dentro de la jerarquía de carpetas del usuario, lo\r\nque podría generar inconsistencias en las comprobaciones de permisos o en la\r\nexperiencia del usuario.​\r\n3.​ Modelo Alternativo: Tabla de Cierre para Jerarquías:​\r\n\r\nEl modelo de tabla de cierre es una solución eficaz para la gestión de datos\r\njerárquicos en bases de datos relacionales.10 Este modelo mantiene una tabla\r\nseparada que registra todas las relaciones ancestro-descendiente dentro de la\r\njerarquía. La tabla de cierre típicamente incluye columnas para el ID del ancestro,\r\nel ID del descendiente y, opcionalmente, la profundidad de la relación.​\r\nEl modelo de tabla de cierre representa todas las relaciones\r\nancestro-descendiente, incluyendo la profundidad, de la siguiente manera: para","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":363,"to":376}}}}],["10",{"pageContent":"El modelo de tabla de cierre representa todas las relaciones\r\nancestro-descendiente, incluyendo la profundidad, de la siguiente manera: para\r\ncada nodo en la jerarquía, la tabla de cierre almacena una fila donde el nodo es\r\ntanto el ancestro como el descendiente, con una profundidad de 0.20 Para cada\r\nrelación directa padre-hijo, se almacena una fila con una profundidad de 1. Las\r\nrelaciones transitivas, como abuelo-nieto, también se registran, con una\r\nprofundidad creciente que indica el número de niveles de separación. La tabla 2\r\nilustra un ejemplo de un esquema de tabla de cierre para la gestión de la\r\njerarquía de carpetas.\r\nTabla\r\n\r\nColumna\r\n\r\nTipo de\r\nDatos\r\n\r\nClave\r\nPrimaria\r\n\r\nFolderDMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre de\r\nla carpeta\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos de\r\nla carpeta\r\n\r\nancestor_id\r\n\r\nINTEGER\r\n\r\nFolderClosur\r\ne\r\n\r\nSí\r\n\r\nClave\r\nForánea\r\n\r\nDescripción\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":375,"to":439}}}}],["11",{"pageContent":"atributos de\r\nla carpeta\r\n\r\nancestor_id\r\n\r\nINTEGER\r\n\r\nFolderClosur\r\ne\r\n\r\nSí\r\n\r\nClave\r\nForánea\r\n\r\nDescripción\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta\r\nancestro\r\n\r\n\fdescendant_\r\nid\r\n\r\nINTEGER\r\n\r\ndepth\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta\r\ndescendient\r\ne\r\nDistancia\r\nentre el\r\nancestro y el\r\ndescendient\r\ne (0 para el\r\nmismo nodo,\r\n1 para el hijo\r\ndirecto, etc.)\r\n\r\nEl modelo de tabla de cierre ofrece varias ventajas en comparación con la estructura\r\nactual. Permite consultar de manera eficiente todos los ancestros o descendientes de\r\nun nodo con una sola unión.[10, 11] Determinar la profundidad de la jerarquía también\r\nes sencillo. La herencia de permisos podría simplificarse consultando la tabla de\r\ncierre para obtener todos los ancestros de un elemento y luego verificando los\r\npermisos asociados a esos ancestros. Sin embargo, el modelo de tabla de cierre","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":414,"to":474}}}}],["12",{"pageContent":"cierre para obtener todos los ancestros de un elemento y luego verificando los\r\npermisos asociados a esos ancestros. Sin embargo, el modelo de tabla de cierre\r\ntambién tiene desventajas. Requiere más espacio de almacenamiento debido a que se\r\nalmacenan todas las rutas. Las operaciones `INSERT` y `DELETE` son más complejas,\r\nya que requieren actualizaciones en la tabla de cierre. Además, podría ser necesario\r\nimplementar triggers para mantener automáticamente la tabla de cierre sincronizada\r\ncon los cambios en la jerarquía.[18, 20, 31] Es importante considerar que mover\r\nsubárboles (carpetas) podría ser más complejo con el modelo de tabla de cierre.[26]​\r\n4.​ Recomendación y Justificación:​\r\n\r\nBasándonos en el análisis de la estructura actual y el modelo alternativo, se\r\nrecomienda cambiar completamente el enfoque y adoptar el modelo de tabla de\r\ncierre para la gestión de la jerarquía de carpetas y documentos, así como para la","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":473,"to":485}}}}],["13",{"pageContent":"recomienda cambiar completamente el enfoque y adoptar el modelo de tabla de\r\ncierre para la gestión de la jerarquía de carpetas y documentos, así como para la\r\nimplementación de la herencia de permisos. Si bien la estructura actual con una\r\ntabla de permisos efectivos puede ofrecer un buen rendimiento para ciertas\r\nconsultas, presenta desafíos significativos en la gestión de la herencia en\r\njerarquías profundas y en el mantenimiento de la consistencia de los datos.​\r\nEl modelo de tabla de cierre, aunque introduce una mayor complejidad en las\r\noperaciones de escritura (inserción, eliminación, movimiento de nodos), ofrece\r\n\r\n\fventajas sustanciales en el rendimiento de las consultas necesarias para la\r\ngestión de permisos jerárquicos y la funcionalidad \"Compartido conmigo\". La\r\ncapacidad de consultar eficientemente todos los ancestros de un elemento\r\npermite implementar la herencia de permisos de manera más directa y con un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":484,"to":496}}}}],["14",{"pageContent":"capacidad de consultar eficientemente todos los ancestros de un elemento\r\npermite implementar la herencia de permisos de manera más directa y con un\r\nmejor rendimiento, ya que se pueden determinar los permisos efectivos para un\r\nusuario en un elemento específico consultando los permisos asociados a todos\r\nsus ancestros en la jerarquía.​\r\nPara la funcionalidad \"Compartido conmigo\", aunque se seguiría necesitando una\r\ntabla Share para registrar los elementos compartidos con usuarios específicos, la\r\nverificación de los permisos efectivos para estos elementos podría beneficiarse\r\ndel modelo de tabla de cierre. Al considerar la jerarquía en la que reside un\r\nelemento compartido (si está dentro de una carpeta), se pueden aplicar las\r\nreglas de herencia de permisos definidas a través de la tabla de cierre.​\r\nLa decisión de recomendar el modelo de tabla de cierre se basa en la\r\nimportancia de un rendimiento eficiente para las consultas de permisos en un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":495,"to":507}}}}],["15",{"pageContent":"La decisión de recomendar el modelo de tabla de cierre se basa en la\r\nimportancia de un rendimiento eficiente para las consultas de permisos en un\r\nsistema de gestión documental, donde las comprobaciones de acceso son una\r\noperación frecuente. Si bien la complejidad de las operaciones de escritura\r\naumenta, esta puede mitigarse mediante el uso de triggers a nivel de base de\r\ndatos que automaticen el mantenimiento de la tabla de cierre, asegurando la\r\nconsistencia de los datos y simplificando la lógica de la aplicación.\r\n5.​ Implementación en PostgreSQL:\r\n○​ Acceso a Datos:\r\n■​ Tabla de Cierre:\r\n■​ Para verificar los permisos de un usuario en un documento o carpeta\r\nespecífica utilizando el modelo de tabla de cierre, se realizaría una\r\nconsulta que una la tabla de cierre (FolderClosure o una tabla similar\r\npara documentos) con las tablas de usuarios, niveles de acceso y la\r\ntabla de nodos (FolderDMS o DocumentDMS). La consulta filtraría por","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":506,"to":520}}}}],["16",{"pageContent":"para documentos) con las tablas de usuarios, niveles de acceso y la\r\ntabla de nodos (FolderDMS o DocumentDMS). La consulta filtraría por\r\nel ID del usuario y el ID del elemento, considerando todos los\r\nancestros del elemento para determinar los permisos heredados. Por\r\nejemplo, para obtener los permisos de un usuario en una carpeta\r\nespecífica:​\r\nSQL​\r\nSELECT al.name​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.ancestor_id = f.folder_id​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE fc.descendant_id = <ID de la carpeta específica>​\r\n\r\n\fAND ep.user_id = <ID del usuario>​\r\nUNION​\r\nSELECT al.name​\r\nFROM FolderDMS f​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE f.folder_id = <ID de la carpeta específica>​\r\nAND ep.user_id = <ID del usuario>;​\r\n\r\n■​ Para obtener todos los documentos y carpetas compartidos con un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":519,"to":542}}}}],["17",{"pageContent":"WHERE f.folder_id = <ID de la carpeta específica>​\r\nAND ep.user_id = <ID del usuario>;​\r\n\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\n\r\nusuario, se consultaría la tabla Share y se uniría con DocumentDMS y\r\nFolderDMS. La verificación de los permisos efectivos para estos\r\nelementos podría entonces utilizar la tabla de cierre para considerar la\r\njerarquía:​\r\nSQL​\r\nSELECT d.name AS document_name, s.access_level_id​\r\nFROM Share s​\r\nJOIN DocumentDMS d ON s.document_id = d.document_id​\r\nWHERE s.shared_with_user_id = <ID del usuario>​\r\nUNION​\r\nSELECT f.name AS folder_name, s.access_level_id​\r\nFROM Share s​\r\nJOIN FolderDMS f ON s.folder_id = f.folder_id​\r\nWHERE s.shared_with_user_id = <ID del usuario>;​\r\n\r\n■​ Para consultar la jerarquía de carpetas y documentos, se uniría la\r\n\r\ntabla de cierre con FolderDMS y DocumentDMS. Por ejemplo, para\r\nobtener toda la jerarquía de carpetas:​\r\nSQL​\r\nSELECT f.name AS descendant, p.name AS ancestor, fc.depth​\r\nFROM FolderClosure fc​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":539,"to":565}}}}],["18",{"pageContent":"tabla de cierre con FolderDMS y DocumentDMS. Por ejemplo, para\r\nobtener toda la jerarquía de carpetas:​\r\nSQL​\r\nSELECT f.name AS descendant, p.name AS ancestor, fc.depth​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.descendant_id = f.folder_id​\r\nJOIN FolderDMS p ON fc.ancestor_id = p.folder_id​\r\nORDER BY fc.depth;​\r\n\r\n■​ Para consultar los permisos efectivos para un usuario en un elemento\r\n\r\nespecífico, considerando la herencia, se consultaría la tabla de cierre\r\npara todos los ancestros del elemento y se uniría con las tablas de\r\npermisos:​\r\nSQL​\r\n\r\n\fSELECT al.name​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.ancestor_id = f.folder_id​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE fc.descendant_id = <ID del elemento>​\r\nAND ep.user_id = <ID del usuario>​\r\nORDER BY fc.depth;​\r\n\r\n○​ Creación de Registros:\r\n■​ Tabla de Cierre:","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":561,"to":587}}}}],["19",{"pageContent":"WHERE fc.descendant_id = <ID del elemento>​\r\nAND ep.user_id = <ID del usuario>​\r\nORDER BY fc.depth;​\r\n\r\n○​ Creación de Registros:\r\n■​ Tabla de Cierre:\r\n■​ Para crear un nuevo documento, se insertaría un registro en la tabla\r\n\r\nDocumentDMS con la información del documento.\r\n■​ Para crear una nueva carpeta, se insertaría un registro en la tabla\r\nFolderDMS con la información de la carpeta. Además, se deberían\r\ninsertar registros en la tabla de cierre (FolderClosure). Esto incluiría\r\nuna entrada auto-referencial (ancestor_id igual a descendant_id y\r\nprofundidad 0) y entradas para cada ancestro de la nueva carpeta. Si\r\nla nueva carpeta es hija de otra, se consultarían los ancestros de la\r\ncarpeta padre en la tabla de cierre y se insertarían nuevas filas para la\r\nnueva carpeta con esos ancestros y una profundidad incrementada en\r\n1. Por ejemplo, para insertar una nueva carpeta con ID new_folder_id\r\ncomo hija de una carpeta con ID parent_folder_id:​\r\nSQL​\r\n-- Insertar la nueva carpeta​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":582,"to":602}}}}],["20",{"pageContent":"1. Por ejemplo, para insertar una nueva carpeta con ID new_folder_id\r\ncomo hija de una carpeta con ID parent_folder_id:​\r\nSQL​\r\n-- Insertar la nueva carpeta​\r\nINSERT INTO FolderDMS (folder_id, parent_folder_id, name) VALUES\r\n\r\n(<new_folder_id>, <parent_folder_id>, '<nombre de la nueva carpeta>');​\r\n​\r\n-- Insertar la entrada auto-referencial en la tabla de cierre​\r\nINSERT INTO FolderClosure (ancestor_id, descendant_id, depth) VALUES\r\n(<new_folder_id>, <new_folder_id>, 0);​\r\n​\r\n-- Insertar entradas para los ancestros (incluyendo el padre)​\r\nINSERT INTO FolderClosure (ancestor_id, descendant_id, depth)​\r\nSELECT ancestor_id, <new_folder_id>, depth + 1​\r\nFROM FolderClosure​\r\nWHERE descendant_id = <parent_folder_id>;​\r\n■​ Para crear un nuevo permiso, se insertaría un registro en la tabla\r\n\r\nEffectivePermission con el ID del usuario, el ID del documento o\r\n\r\n\fcarpeta y el ID del nivel de acceso.\r\n6.​ Integración con Prisma ORM:\r\n○​ Definición de Modelos de Prisma:","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":599,"to":622}}}}],["21",{"pageContent":"EffectivePermission con el ID del usuario, el ID del documento o\r\n\r\n\fcarpeta y el ID del nivel de acceso.\r\n6.​ Integración con Prisma ORM:\r\n○​ Definición de Modelos de Prisma:\r\n■​ Para la estructura de base de datos con tabla de cierre, los modelos de\r\nPrisma correspondientes a las tablas DocumentDMS, FolderDMS,\r\nFolderClosure, EffectivePermission, Share y AccessLevel se definirían de\r\nla siguiente manera:​\r\nFragmento de código​\r\n\r\nmodel DocumentDMS {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nfolderId Int​\r\nname\r\nString​\r\nfolder FolderDMS @relation(fields: [folderId], references: [id])​\r\neffectivePermissions EffectivePermission​\r\nshares\r\nShare​\r\n}​\r\n​\r\nmodel FolderDMS {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nparentFolderId Int?​\r\nname\r\nString​\r\ndocuments\r\nDocumentDMS​\r\nparentFolder FolderDMS? @relation(\"FolderHierarchy\", fields:\r\n[parentFolderId], references: [id], onDelete: Cascade, onUpdate:\r\nCascade)​\r\nchildFolders FolderDMS @relation(\"FolderHierarchy\")​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":618,"to":654}}}}],["22",{"pageContent":"parentFolder FolderDMS? @relation(\"FolderHierarchy\", fields:\r\n[parentFolderId], references: [id], onDelete: Cascade, onUpdate:\r\nCascade)​\r\nchildFolders FolderDMS @relation(\"FolderHierarchy\")​\r\nancestorClosure FolderClosure @relation(\"Ancestor\")​\r\ndescendantClosure FolderClosure @relation(\"Descendant\")​\r\neffectivePermissions EffectivePermission​\r\nshares\r\nShare​\r\n}​\r\n​\r\nmodel FolderClosure {​\r\nancestorId Int​\r\ndescendantId Int​\r\ndepth\r\nInt​\r\nancestor FolderDMS @relation(\"Ancestor\", fields: [ancestorId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\ndescendant FolderDMS @relation(\"Descendant\", fields: [descendantId],\r\n\r\n\freferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n​\r\n@@id([ancestorId, descendantId])​\r\n}​\r\n​\r\nmodel EffectivePermission {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nuserId\r\nInt​\r\ndocumentId Int?​\r\nfolderId\r\nInt?​\r\naccessLevelId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":651,"to":688}}}}],["23",{"pageContent":"userId\r\nInt​\r\ndocumentId Int?​\r\nfolderId\r\nInt?​\r\naccessLevelId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\nfolder\r\nFolderDMS? @relation(fields: [folderId], references: [id],\r\nonDelete: Cascade, onUpdate: Cascade)​\r\naccessLevel AccessLevel @relation(fields: [accessLevelId], references:\r\n[id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel Share {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\ndocumentId\r\nInt?​\r\nfolderId\r\nInt?​\r\nsharedWithUserId Int​\r\naccessLevelId\r\nInt​\r\nsharedByUserId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\nfolder\r\nFolderDMS? @relation(fields: [folderId], references: [id],\r\nonDelete: Cascade, onUpdate: Cascade)​\r\naccessLevel\r\nAccessLevel @relation(fields: [accessLevelId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel AccessLevel {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nname\r\nString​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":680,"to":724}}}}],["24",{"pageContent":"AccessLevel @relation(fields: [accessLevelId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel AccessLevel {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nname\r\nString​\r\npermissionsMask Int​\r\neffectivePermissions EffectivePermission​\r\n\r\n\fshares\r\n}​\r\n\r\nShare​\r\n\r\n○​ Uso del Cliente de Prisma para Consultas:\r\n■​ Para verificar los permisos de un usuario en una carpeta específica:​\r\nTypeScript​\r\nconst permissions = await prisma.folderClosure.findMany({​\r\nwhere: {​\r\ndescendantId: folderId,​\r\nancestor: {​\r\neffectivePermissions: {​\r\nsome: {​\r\nuserId: userId,​\r\nfolderId: { not: null },​\r\n\r\n},​\r\n},​\r\n},​\r\n},​\r\ninclude: {​\r\nancestor: {​\r\ninclude: {​\r\neffectivePermissions: {​\r\nwhere: { userId: userId },​\r\ninclude: { accessLevel: true },​\r\n\r\n},​\r\n},​\r\n},​\r\n},​\r\n});​\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\nusuario:​\r\nTypeScript​\r\nconst sharedItems = await prisma.share.findMany({​\r\nwhere: { sharedWithUserId: userId },​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":715,"to":765}}}}],["25",{"pageContent":"},​\r\n},​\r\n});​\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\nusuario:​\r\nTypeScript​\r\nconst sharedItems = await prisma.share.findMany({​\r\nwhere: { sharedWithUserId: userId },​\r\ninclude: { document: true, folder: true, accessLevel: true },​\r\n\r\n});​\r\n■​ Para consultar la jerarquía de carpetas:​\r\n\r\n\fTypeScript​\r\nconst folderHierarchy = await prisma.folderClosure.findMany({​\r\ninclude: {​\r\nancestor: { select: { id: true, name: true } },​\r\ndescendant: { select: { id: true, name: true } },​\r\n\r\n},​\r\norderBy: { depth: 'asc' },​\r\n\r\n});​\r\n■​ Para obtener los permisos efectivos para un usuario en una carpeta\r\nespecífica (simplificado):​\r\nTypeScript​\r\nconst effectivePermissions = await prisma.effectivePermission.findMany({​\r\nwhere: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\n\r\n},​\r\ninclude: { accessLevel: true },​\r\n\r\n});​\r\n○​ Uso del Cliente de Prisma para Crear Registros:\r\n■​ Para crear una nueva carpeta:​\r\nTypeScript​\r\nconst newFolder = await prisma.folderDMS.create({​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":758,"to":796}}}}],["26",{"pageContent":"},​\r\ninclude: { accessLevel: true },​\r\n\r\n});​\r\n○​ Uso del Cliente de Prisma para Crear Registros:\r\n■​ Para crear una nueva carpeta:​\r\nTypeScript​\r\nconst newFolder = await prisma.folderDMS.create({​\r\ndata: {​\r\nname: folderName,​\r\nparentFolderId: parentFolderId,​\r\nancestorClosure: {​\r\ncreate: [​\r\n\r\n{ ancestorId: newFolderId, depth: 0 }, // Auto-referencia​\r\n//... (Lógica para crear entradas de ancestros basada en el parentFolderId)​\r\n\r\n],​\r\n},​\r\n},​\r\n});​\r\n■​ Para crear un nuevo documento:​\r\nTypeScript​\r\nconst newDocument = await prisma.documentDMS.create({​\r\ndata: {​\r\n\r\n\fname: documentName,​\r\nfolderId: folderId,​\r\n\r\n},​\r\n});​\r\n■​ Para crear un nuevo permiso:​\r\nTypeScript​\r\nconst newPermission = await prisma.effectivePermission.create({​\r\ndata: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\naccessLevelId: accessLevelId,​\r\n\r\n},​\r\n});​\r\n7.​ Conclusión:​\r\n\r\nEl análisis presentado sugiere que la adopción del modelo de tabla de cierre para","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":789,"to":832}}}}],["27",{"pageContent":"data: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\naccessLevelId: accessLevelId,​\r\n\r\n},​\r\n});​\r\n7.​ Conclusión:​\r\n\r\nEl análisis presentado sugiere que la adopción del modelo de tabla de cierre para\r\nla gestión de la jerarquía de carpetas y documentos ofrece ventajas significativas\r\nen términos de rendimiento de consultas para la gestión de permisos jerárquicos\r\ny la funcionalidad \"Compartido conmigo\". Si bien este modelo introduce una\r\nmayor complejidad en las operaciones de escritura, los beneficios en la eficiencia\r\nde las consultas, especialmente en sistemas con jerarquías profundas y un alto\r\nvolumen de comprobaciones de permisos, justifican el cambio de enfoque. Se\r\nrecomienda realizar pruebas de rendimiento exhaustivas con volúmenes de datos\r\ny patrones de consulta realistas para validar los beneficios esperados. También\r\nse deben considerar el impacto de la migración en los datos existentes y la curva\r\nde aprendizaje para el equipo con respecto al nuevo modelo.\r\nObras citadas","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":823,"to":843}}}}],["28",{"pageContent":"se deben considerar el impacto de la migración en los datos existentes y la curva\r\nde aprendizaje para el equipo con respecto al nuevo modelo.\r\nObras citadas\r\n1.​ Organize your files | Data management - MIT Libraries, fecha de acceso: abril 16,\r\n\r\n2025, https://libraries.mit.edu/data-management/store/organize/\r\n\r\n2.​ Directory Structure - Harvard Biomedical Data Management, fecha de acceso:\r\n\r\nabril 16, 2025,\r\nhttps://datamanagement.hms.harvard.edu/plan-design/directory-structure\r\n3.​ Designing a data file structure - CESSDA Data Management Expert Guide, fecha\r\nde acceso: abril 16, 2025,\r\nhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/Designing-a-data-file-structure\r\n4.​ File naming and folder structure - CESSDA Data Management Expert Guide,\r\nfecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/File-naming-and-folder-structure","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":841,"to":860}}}}],["29",{"pageContent":"fecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/File-naming-and-folder-structure\r\n5.​ File and Folder Organization - long draft - UC Merced Library, fecha de acceso:\r\nabril 16, 2025, https://library.ucmerced.edu/node/66751\r\n6.​ The Guide to Folder Structures - SuiteFiles, fecha de acceso: abril 16, 2025,\r\nhttps://www.suitefiles.com/guides/folder-structures-guide/\r\n7.​ Collaborative Document Management - Interfacing Technologies, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://interfacing.com/collaborative-document-management\r\n8.​ What is a Document Management System? - IRIS Software Group, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://www.irisglobal.com/blog/what-is-a-document-management-system/\r\n9.​ Understanding Permission Inheritance - Seeq Knowledge Base, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://support.seeq.com/kb/R64/cloud/understanding-permission-inheritance","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":857,"to":873}}}}],["30",{"pageContent":"9.​ Understanding Permission Inheritance - Seeq Knowledge Base, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://support.seeq.com/kb/R64/cloud/understanding-permission-inheritance\r\n10.​Hierarchical models in PostgreSQL | Ackee blog, fecha de acceso: abril 16, 2025,\r\nhttps://www.ackee.agency/blog/hierarchical-models-in-postgresql\r\n11.​ Closure Table | The Cache • Fueled Engineering, fecha de acceso: abril 16, 2025,\r\nhttps://fueled.com/the-cache/posts/backend/closure-table/\r\n12.​Database design for file sharing system like Google drive : r/AskProgramming Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/AskProgramming/comments/1g3msfs/database_design\r\n_for_file_sharing_system_like/\r\n13.​How to design a functionality to share content? - Software Engineering Stack\r\nExchange, fecha de acceso: abril 16, 2025,\r\nhttps://softwareengineering.stackexchange.com/questions/348606/how-to-desig\r\nn-a-functionality-to-share-content","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":871,"to":884}}}}],["31",{"pageContent":"Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://softwareengineering.stackexchange.com/questions/348606/how-to-desig\r\nn-a-functionality-to-share-content\r\n14.​SQL Server Closure Tables - Simple Talk - Redgate Software, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://www.red-gate.com/simple-talk/databases/sql-server/t-sql-programmingsql-server/sql-server-closure-tables/\r\n15.​Recursive CTE vs closure table for storing hierarchical information : r/PostgreSQL\r\n- Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/PostgreSQL/comments/1777s0t/recursive_cte_vs_closu\r\nre_table_for_storing/\r\n16.​Transitive Closure in PostgreSQL - Remind Engineering, fecha de acceso: abril 16,\r\n2025, https://engineering.remind.com/Transitive-Closure-In-PostgreSQL/\r\n17.​franzose/ClosureTable: Adjacency List'ed Closure Table database design pattern\r\nimplementation for the Laravel framework. - GitHub, fecha de acceso: abril 16,\r\n2025, https://github.com/franzose/ClosureTable","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":882,"to":896}}}}],["32",{"pageContent":"implementation for the Laravel framework. - GitHub, fecha de acceso: abril 16,\r\n2025, https://github.com/franzose/ClosureTable\r\n18.​This is a mysql and postgresql store procedure and trigger implementation of\r\nclosure table in RDBMS about hierarchy data model. - GitHub, fecha de acceso:\r\nabril 16, 2025, https://github.com/developerworks/hierarchy-data-closure-table\r\n19.​The relational modeling of hierarchical data in biodiversity databases - Oxford\r\nAcademic, fecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://academic.oup.com/database/article/doi/10.1093/database/baae107/781784\r\n3\r\n20.​Store Hierarchical Data Seamlessly | PostgreSQL - Closure Table, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://technobytz.com/closure_table_store_hierarchical_data.html\r\n21.​WillSoss/closure-tree: A closure table implementation in C#/MSSQL. - GitHub,\r\nfecha de acceso: abril 16, 2025, https://github.com/WillSoss/closure-tree\r\n22.​Choice of Database schema for storing folder system - Stack Overflow, fecha de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":895,"to":910}}}}],["33",{"pageContent":"fecha de acceso: abril 16, 2025, https://github.com/WillSoss/closure-tree\r\n22.​Choice of Database schema for storing folder system - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/13104601/choice-of-database-schema-forstoring-folder-system\r\n23.​Moving Subtrees in Closure Table Hierarchies - Percona, fecha de acceso: abril 16,\r\n2025, https://www.percona.com/blog/moving-subtrees-in-closure-table/\r\n24.​The simplest(?) way to do tree-based queries in SQL - dirtSimple.org, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html\r\n25.​How can I create a closure table using data from an adjacency list? - Stack\r\nOverflow, fecha de acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/12621873/how-can-i-create-a-closure-table\r\n-using-data-from-an-adjacency-list\r\n26.​Rendering Trees with Closure Tables – Keeping It Simple - Karwin, fecha de\r\nacceso: abril 16, 2025,","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":909,"to":923}}}}],["34",{"pageContent":"-using-data-from-an-adjacency-list\r\n26.​Rendering Trees with Closure Tables – Keeping It Simple - Karwin, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://karwin.com/blog/index.php/2010/03/24/rendering-trees-with-closure-tabl\r\nes/\r\n27.​Hierarchical Structures in PostgreSQL (2020) - Hacker News, fecha de acceso:\r\nabril 16, 2025, https://news.ycombinator.com/item?id=27631765\r\n28.​Working with Graphs in Postgres Part 2: Extending the Closure Table Pattern to\r\nSupport DAGs - Lucas Nagle, fecha de acceso: abril 16, 2025,\r\nhttps://lnagle.github.io/extended-closure-table-pattern.html\r\n29.​data modeling - Managing hierarchies in SQL: MPTT/nested sets vs ..., fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/8196175/managing-hierarchies-in-sql-mpttnested-sets-vs-adjacency-lists-vs-storing-path\r\n30.​Moving in Closure Table with Multiple Parents - sql - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":921,"to":935}}}}],["35",{"pageContent":"30.​Moving in Closure Table with Multiple Parents - sql - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/9641932/moving-in-closure-table-with-multi\r\nple-parents\r\n31.​Hierarchical data using closure table, how to ensure that a column is unique within\r\nthe parent node? - DBA Stack Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/269404/hierarchical-data-using-closur\r\ne-table-how-to-ensure-that-a-column-is-unique-wit\r\n32.​Implementing version history with a closure table schema - Stack Overflow, fecha\r\nde acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/13457479/implementing-version-history-wit\r\nh-a-closure-table-schema\r\n\r\n\f33.​Worked example of closure tables with from and thru dates - DBA Stack\r\n\r\nExchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/230966/worked-example-of-closure-t\r\nables-with-from-and-thru-dates","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":934,"to":951}}}}],["36",{"pageContent":"Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/230966/worked-example-of-closure-t\r\nables-with-from-and-thru-dates\r\n34.​Use closure tables to implement file cache without full path column · Issue #4209\r\n· owncloud/core - GitHub, fecha de acceso: abril 16, 2025,\r\nhttps://github.com/owncloud/core/issues/4209\r\n35.​When inserting why does a closure table point to itself - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/22416571/when-inserting-why-does-a-closu\r\nre-table-point-to-itself\r\n36.​hierarchical data in a database: recursive query vs. closure tables vs. graph\r\ndatabase, fecha de acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/7497812/hierarchical-data-in-a-database-re\r\ncursive-query-vs-closure-tables-vs-graph-da\r\n37.​How to Store and Query Categories : r/PHP - Reddit, fecha de acceso: abril 16,\r\n2025,\r\nhttps://www.reddit.com/r/PHP/comments/l72ve8/how_to_store_and_query_categ\r\nories/","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":949,"to":966}}}}],["37",{"pageContent":"37.​How to Store and Query Categories : r/PHP - Reddit, fecha de acceso: abril 16,\r\n2025,\r\nhttps://www.reddit.com/r/PHP/comments/l72ve8/how_to_store_and_query_categ\r\nories/\r\n38.​How would you model a file tree? : r/SQL - Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/SQL/comments/rt3d9a/how_would_you_model_a_file_tr\r\nee/\r\n39.​Nested Sets vs Closure Table in real life apps : r/PHP - Reddit, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://www.reddit.com/r/PHP/comments/3mgomv/nested_sets_vs_closure_table_\r\nin_real_life_apps/\r\n\r\n\f\r\n\r\nEste analisis fue realizado por Aaron Santander","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":963,"to":977}}}}],["38",{"pageContent":"Análisis y Recomendaciones para la Gestión de Permisos\r\nJerárquicos en un Sistema de Gestión Documental\r\n1.​ Introducción:​\r\n\r\nLa gestión de permisos robusta y escalable en sistemas de gestión documental\r\nes fundamental para garantizar la seguridad de los datos y el cumplimiento\r\nnormativo. La introducción de permisos jerárquicos añade una capa de\r\ncomplejidad, requiriendo una consideración cuidadosa de la herencia y los\r\ndiferentes niveles de acceso. Una estructura de base de datos eficiente es\r\nesencial para asegurar el rendimiento, la escalabilidad y la mantenibilidad de la\r\ngestión de permisos y las funcionalidades de compartición. Esquemas mal\r\ndiseñados pueden conducir a consultas complejas, rendimiento lento y posibles\r\nvulnerabilidades de seguridad. El presente informe tiene como objetivo analizar\r\ncríticamente la estructura de base de datos actual, evaluar su idoneidad para los\r\nrequisitos especificados y proporcionar una recomendación bien justificada","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":1,"to":15}}}}],["39",{"pageContent":"críticamente la estructura de base de datos actual, evaluar su idoneidad para los\r\nrequisitos especificados y proporcionar una recomendación bien justificada\r\nsobre el enfoque óptimo, incluyendo una guía práctica para su implementación.\r\n2.​ Análisis Crítico de la Estructura Actual de la Base de Datos:​\r\nEl esquema actual de la base de datos consta de las tablas DocumentDMS,\r\nFolderDMS, EffectivePermission, Share y AccessLevel, cuyas relaciones son\r\ncruciales para comprender la gestión de permisos. Es fundamental entender las\r\ncolumnas de cada tabla y las relaciones que existen entre ellas, como las claves\r\nforáneas. La forma en que se relacionan los documentos y las carpetas, y si\r\nexiste una relación auto-referencial en FolderDMS para representar la jerarquía,\r\nson aspectos importantes a considerar. También es necesario analizar cómo se\r\nvinculan los permisos a los usuarios, documentos o carpetas y los niveles de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":14,"to":25}}}}],["40",{"pageContent":"son aspectos importantes a considerar. También es necesario analizar cómo se\r\nvinculan los permisos a los usuarios, documentos o carpetas y los niveles de\r\nacceso, así como el papel de la tabla Share en la concesión de acceso a otros\r\nusuarios. La presencia de la tabla EffectivePermission sugiere un cálculo previo o\r\nmaterialización de los permisos, por lo que es necesario comprender cómo se\r\npuebla y se mantiene esta tabla.​\r\nLas estrategias para la organización de archivos y carpetas a nivel de sistema de\r\narchivos enfatizan la importancia de las estructuras jerárquicas y las\r\nconvenciones de nomenclatura consistentes.1 Es probable que estas\r\nconsideraciones se reflejen en las tablas FolderDMS y DocumentDMS, aunque no\r\ndetallan directamente el aspecto de los permisos. Sistemas de gestión\r\ndocumental eficaces deben ofrecer control de acceso y privilegios de edición 7, lo\r\nque sugiere que el esquema actual probablemente tiene como objetivo soportar","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":24,"to":36}}}}],["41",{"pageContent":"documental eficaces deben ofrecer control de acceso y privilegios de edición 7, lo\r\nque sugiere que el esquema actual probablemente tiene como objetivo soportar\r\nestas funcionalidades. La tabla 1 presenta una posible estructura para el\r\nesquema actual de la base de datos, aunque la estructura real puede variar.\r\n\r\n\fTabla\r\n\r\nColumna\r\n\r\nTipo de\r\nDatos\r\n\r\nClave\r\nPrimaria\r\n\r\nDocumentD\r\nMS\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre del\r\ndocumento\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos del\r\ndocumento\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nparent_folde\r\nr_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre de\r\nla carpeta\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos de\r\nla carpeta\r\n\r\neffective_per\r\nmission_id\r\n\r\nINTEGER\r\n\r\nFolderDMS\r\n\r\nEffectivePer\r\nmission\r\n\r\nClave\r\nForánea\r\n\r\nIdentificador\r\núnico del\r\ndocumento\r\nSí\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\nque contiene\r\nel\r\ndocumento\r\nen\r\nFolderDMS\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\nSí (a sí\r\nmismo)\r\n\r\nSí\r\n\r\nDescripción\r\n\r\nReferencia a","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":35,"to":140}}}}],["42",{"pageContent":"único del\r\ndocumento\r\nSí\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\nque contiene\r\nel\r\ndocumento\r\nen\r\nFolderDMS\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\nSí (a sí\r\nmismo)\r\n\r\nSí\r\n\r\nDescripción\r\n\r\nReferencia a\r\nla carpeta\r\npadre en\r\nFolderDMS\r\n(para la\r\njerarquía)\r\n\r\nIdentificador\r\núnico del\r\npermiso\r\n\r\n\fefectivo\r\n\r\nShare\r\n\r\nuser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\ndocumento\r\nen\r\nDocumentD\r\nMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta en\r\nFolderDMS\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\nnivel de\r\nacceso en\r\nAccessLevel\r\n(ej., lectura,\r\nescritura)\r\n\r\n...\r\n\r\n...\r\n\r\nshare_id\r\n\r\nINTEGER\r\n\r\ndocument_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia al\r\ndocumento\r\ncompartido\r\nen\r\nDocumentD\r\nMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nReferencia a\r\nla carpeta\r\ncompartida\r\nen\r\n\r\nOtros\r\natributos del\r\npermiso\r\nefectivo\r\nSí\r\n\r\nIdentificador\r\núnico del\r\nrecurso\r\ncompartido\r\n\r\n\fFolderDMS\r\n\r\nAccessLevel\r\n\r\nshared_with_\r\nuser_id\r\n\r\nINTEGER","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":116,"to":248}}}}],["43",{"pageContent":"la carpeta\r\ncompartida\r\nen\r\n\r\nOtros\r\natributos del\r\npermiso\r\nefectivo\r\nSí\r\n\r\nIdentificador\r\núnico del\r\nrecurso\r\ncompartido\r\n\r\n\fFolderDMS\r\n\r\nAccessLevel\r\n\r\nshared_with_\r\nuser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario con\r\nel que se\r\ncomparte\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nshared_by_u\r\nser_id\r\n\r\nINTEGER\r\n\r\nReferencia al\r\nusuario que\r\ncompartió el\r\nrecurso\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos del\r\nrecurso\r\ncompartido\r\n(ej., fecha de\r\ncompartición\r\n)\r\n\r\naccess_level\r\n_id\r\n\r\nINTEGER\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre del\r\nnivel de\r\nacceso (ej.,\r\nLectura,\r\nEscritura,\r\nEdición)\r\n\r\npermissions_\r\nmask\r\n\r\nINTEGER\r\n\r\nMáscara de\r\nbits o valor\r\nque\r\nrepresenta\r\n\r\nSí\r\n\r\nSí\r\n\r\nReferencia al\r\nnivel de\r\nacceso para\r\nel recurso\r\ncompartido\r\nen\r\nAccessLevel\r\n\r\nIdentificador\r\núnico del\r\nnivel de\r\nacceso\r\n\r\n\flos permisos\r\nespecíficos\r\nasociados a\r\neste nivel de\r\nacceso\r\n\r\nLa idoneidad de la estructura actual para representar permisos jerárquicos multinivel","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":226,"to":331}}}}],["44",{"pageContent":"Identificador\r\núnico del\r\nnivel de\r\nacceso\r\n\r\n\flos permisos\r\nespecíficos\r\nasociados a\r\neste nivel de\r\nacceso\r\n\r\nLa idoneidad de la estructura actual para representar permisos jerárquicos multinivel\r\ndepende de cómo se gestiona la relación `parent_folder_id` en `FolderDMS` y cómo\r\nse utiliza la tabla `EffectivePermission` para aplicar estos permisos a través de la\r\njerarquía. La herencia de permisos, donde los permisos establecidos en una carpeta\r\nse propagan a sus subcarpetas y documentos, es un requisito fundamental.[9] La\r\nestructura actual debe implementar un mecanismo similar, posiblemente a través de\r\nla tabla `EffectivePermission` o mediante lógica de aplicación que consulte las\r\nrelaciones entre carpetas. La gestión de diferentes niveles de acceso (por ejemplo,\r\nlectura, escritura, eliminación) probablemente se maneja mediante la tabla\r\n`AccessLevel` y su columna `permissions_mask`, que permite definir granularmente\r\nlas acciones permitidas para cada nivel.​\r\n​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":320,"to":342}}}}],["45",{"pageContent":"`AccessLevel` y su columna `permissions_mask`, que permite definir granularmente\r\nlas acciones permitidas para cada nivel.​\r\n​\r\nSin embargo, la estructura actual podría presentar limitaciones para implementar\r\neficientemente la herencia de permisos a través de una jerarquía profunda de\r\ndocumentos y carpetas. Si `FolderDMS` utiliza un modelo de lista de adyacencia\r\n(donde cada carpeta simplemente apunta a su padre), la consulta de los permisos\r\nefectivos para un usuario en un elemento específico, considerando la herencia, podría\r\nrequerir consultas recursivas o múltiples uniones, lo que puede ser ineficiente para\r\njerarquías muy anidadas.[10, 11] Mantener la tabla `EffectivePermission` consistente\r\ncon los cambios en la jerarquía o los permisos explícitos también podría ser complejo\r\ny consumir muchos recursos, requiriendo la implementación de triggers o trabajos por\r\nlotes para asegurar la integridad de los datos. Además, es importante considerar","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":340,"to":352}}}}],["46",{"pageContent":"y consumir muchos recursos, requiriendo la implementación de triggers o trabajos por\r\nlotes para asegurar la integridad de los datos. Además, es importante considerar\r\ncómo la estructura actual maneja las excepciones a los permisos heredados en\r\nniveles inferiores de la jerarquía.​\r\n​\r\nLa funcionalidad \"Compartido conmigo\" probablemente se implementa a través de la\r\ntabla `Share`, que registra los elementos que se han compartido con usuarios\r\nespecíficos. Esta tabla probablemente contiene referencias al documento o carpeta\r\ncompartida, al usuario con el que se comparte, al usuario que compartió el elemento\r\ny al nivel de acceso otorgado.[12, 13] La eficiencia de la consulta para obtener todos\r\n\r\n\flos elementos compartidos con un usuario dependerá de la indexación y la estructura\r\nde la tabla `Share`, así como de las uniones necesarias con `DocumentDMS` y\r\n`FolderDMS`. Es posible que la estructura actual trate los elementos compartidos de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":351,"to":364}}}}],["47",{"pageContent":"de la tabla `Share`, así como de las uniones necesarias con `DocumentDMS` y\r\n`FolderDMS`. Es posible que la estructura actual trate los elementos compartidos de\r\nmanera diferente a los elementos dentro de la jerarquía de carpetas del usuario, lo\r\nque podría generar inconsistencias en las comprobaciones de permisos o en la\r\nexperiencia del usuario.​\r\n3.​ Modelo Alternativo: Tabla de Cierre para Jerarquías:​\r\n\r\nEl modelo de tabla de cierre es una solución eficaz para la gestión de datos\r\njerárquicos en bases de datos relacionales.10 Este modelo mantiene una tabla\r\nseparada que registra todas las relaciones ancestro-descendiente dentro de la\r\njerarquía. La tabla de cierre típicamente incluye columnas para el ID del ancestro,\r\nel ID del descendiente y, opcionalmente, la profundidad de la relación.​\r\nEl modelo de tabla de cierre representa todas las relaciones\r\nancestro-descendiente, incluyendo la profundidad, de la siguiente manera: para","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":363,"to":376}}}}],["48",{"pageContent":"El modelo de tabla de cierre representa todas las relaciones\r\nancestro-descendiente, incluyendo la profundidad, de la siguiente manera: para\r\ncada nodo en la jerarquía, la tabla de cierre almacena una fila donde el nodo es\r\ntanto el ancestro como el descendiente, con una profundidad de 0.20 Para cada\r\nrelación directa padre-hijo, se almacena una fila con una profundidad de 1. Las\r\nrelaciones transitivas, como abuelo-nieto, también se registran, con una\r\nprofundidad creciente que indica el número de niveles de separación. La tabla 2\r\nilustra un ejemplo de un esquema de tabla de cierre para la gestión de la\r\njerarquía de carpetas.\r\nTabla\r\n\r\nColumna\r\n\r\nTipo de\r\nDatos\r\n\r\nClave\r\nPrimaria\r\n\r\nFolderDMS\r\n\r\nfolder_id\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nname\r\n\r\nVARCHAR\r\n\r\nNombre de\r\nla carpeta\r\n\r\n...\r\n\r\n...\r\n\r\nOtros\r\natributos de\r\nla carpeta\r\n\r\nancestor_id\r\n\r\nINTEGER\r\n\r\nFolderClosur\r\ne\r\n\r\nSí\r\n\r\nClave\r\nForánea\r\n\r\nDescripción\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":375,"to":439}}}}],["49",{"pageContent":"atributos de\r\nla carpeta\r\n\r\nancestor_id\r\n\r\nINTEGER\r\n\r\nFolderClosur\r\ne\r\n\r\nSí\r\n\r\nClave\r\nForánea\r\n\r\nDescripción\r\n\r\nIdentificador\r\núnico de la\r\ncarpeta\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta\r\nancestro\r\n\r\n\fdescendant_\r\nid\r\n\r\nINTEGER\r\n\r\ndepth\r\n\r\nINTEGER\r\n\r\nSí\r\n\r\nFolderDMS\r\n(folder_id)\r\n\r\nID de la\r\ncarpeta\r\ndescendient\r\ne\r\nDistancia\r\nentre el\r\nancestro y el\r\ndescendient\r\ne (0 para el\r\nmismo nodo,\r\n1 para el hijo\r\ndirecto, etc.)\r\n\r\nEl modelo de tabla de cierre ofrece varias ventajas en comparación con la estructura\r\nactual. Permite consultar de manera eficiente todos los ancestros o descendientes de\r\nun nodo con una sola unión.[10, 11] Determinar la profundidad de la jerarquía también\r\nes sencillo. La herencia de permisos podría simplificarse consultando la tabla de\r\ncierre para obtener todos los ancestros de un elemento y luego verificando los\r\npermisos asociados a esos ancestros. Sin embargo, el modelo de tabla de cierre","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":414,"to":474}}}}],["50",{"pageContent":"cierre para obtener todos los ancestros de un elemento y luego verificando los\r\npermisos asociados a esos ancestros. Sin embargo, el modelo de tabla de cierre\r\ntambién tiene desventajas. Requiere más espacio de almacenamiento debido a que se\r\nalmacenan todas las rutas. Las operaciones `INSERT` y `DELETE` son más complejas,\r\nya que requieren actualizaciones en la tabla de cierre. Además, podría ser necesario\r\nimplementar triggers para mantener automáticamente la tabla de cierre sincronizada\r\ncon los cambios en la jerarquía.[18, 20, 31] Es importante considerar que mover\r\nsubárboles (carpetas) podría ser más complejo con el modelo de tabla de cierre.[26]​\r\n4.​ Recomendación y Justificación:​\r\n\r\nBasándonos en el análisis de la estructura actual y el modelo alternativo, se\r\nrecomienda cambiar completamente el enfoque y adoptar el modelo de tabla de\r\ncierre para la gestión de la jerarquía de carpetas y documentos, así como para la","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":473,"to":485}}}}],["51",{"pageContent":"recomienda cambiar completamente el enfoque y adoptar el modelo de tabla de\r\ncierre para la gestión de la jerarquía de carpetas y documentos, así como para la\r\nimplementación de la herencia de permisos. Si bien la estructura actual con una\r\ntabla de permisos efectivos puede ofrecer un buen rendimiento para ciertas\r\nconsultas, presenta desafíos significativos en la gestión de la herencia en\r\njerarquías profundas y en el mantenimiento de la consistencia de los datos.​\r\nEl modelo de tabla de cierre, aunque introduce una mayor complejidad en las\r\noperaciones de escritura (inserción, eliminación, movimiento de nodos), ofrece\r\n\r\n\fventajas sustanciales en el rendimiento de las consultas necesarias para la\r\ngestión de permisos jerárquicos y la funcionalidad \"Compartido conmigo\". La\r\ncapacidad de consultar eficientemente todos los ancestros de un elemento\r\npermite implementar la herencia de permisos de manera más directa y con un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":484,"to":496}}}}],["52",{"pageContent":"capacidad de consultar eficientemente todos los ancestros de un elemento\r\npermite implementar la herencia de permisos de manera más directa y con un\r\nmejor rendimiento, ya que se pueden determinar los permisos efectivos para un\r\nusuario en un elemento específico consultando los permisos asociados a todos\r\nsus ancestros en la jerarquía.​\r\nPara la funcionalidad \"Compartido conmigo\", aunque se seguiría necesitando una\r\ntabla Share para registrar los elementos compartidos con usuarios específicos, la\r\nverificación de los permisos efectivos para estos elementos podría beneficiarse\r\ndel modelo de tabla de cierre. Al considerar la jerarquía en la que reside un\r\nelemento compartido (si está dentro de una carpeta), se pueden aplicar las\r\nreglas de herencia de permisos definidas a través de la tabla de cierre.​\r\nLa decisión de recomendar el modelo de tabla de cierre se basa en la\r\nimportancia de un rendimiento eficiente para las consultas de permisos en un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":495,"to":507}}}}],["53",{"pageContent":"La decisión de recomendar el modelo de tabla de cierre se basa en la\r\nimportancia de un rendimiento eficiente para las consultas de permisos en un\r\nsistema de gestión documental, donde las comprobaciones de acceso son una\r\noperación frecuente. Si bien la complejidad de las operaciones de escritura\r\naumenta, esta puede mitigarse mediante el uso de triggers a nivel de base de\r\ndatos que automaticen el mantenimiento de la tabla de cierre, asegurando la\r\nconsistencia de los datos y simplificando la lógica de la aplicación.\r\n5.​ Implementación en PostgreSQL:\r\n○​ Acceso a Datos:\r\n■​ Tabla de Cierre:\r\n■​ Para verificar los permisos de un usuario en un documento o carpeta\r\nespecífica utilizando el modelo de tabla de cierre, se realizaría una\r\nconsulta que una la tabla de cierre (FolderClosure o una tabla similar\r\npara documentos) con las tablas de usuarios, niveles de acceso y la\r\ntabla de nodos (FolderDMS o DocumentDMS). La consulta filtraría por","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":506,"to":520}}}}],["54",{"pageContent":"para documentos) con las tablas de usuarios, niveles de acceso y la\r\ntabla de nodos (FolderDMS o DocumentDMS). La consulta filtraría por\r\nel ID del usuario y el ID del elemento, considerando todos los\r\nancestros del elemento para determinar los permisos heredados. Por\r\nejemplo, para obtener los permisos de un usuario en una carpeta\r\nespecífica:​\r\nSQL​\r\nSELECT al.name​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.ancestor_id = f.folder_id​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE fc.descendant_id = <ID de la carpeta específica>​\r\n\r\n\fAND ep.user_id = <ID del usuario>​\r\nUNION​\r\nSELECT al.name​\r\nFROM FolderDMS f​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE f.folder_id = <ID de la carpeta específica>​\r\nAND ep.user_id = <ID del usuario>;​\r\n\r\n■​ Para obtener todos los documentos y carpetas compartidos con un","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":519,"to":542}}}}],["55",{"pageContent":"WHERE f.folder_id = <ID de la carpeta específica>​\r\nAND ep.user_id = <ID del usuario>;​\r\n\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\n\r\nusuario, se consultaría la tabla Share y se uniría con DocumentDMS y\r\nFolderDMS. La verificación de los permisos efectivos para estos\r\nelementos podría entonces utilizar la tabla de cierre para considerar la\r\njerarquía:​\r\nSQL​\r\nSELECT d.name AS document_name, s.access_level_id​\r\nFROM Share s​\r\nJOIN DocumentDMS d ON s.document_id = d.document_id​\r\nWHERE s.shared_with_user_id = <ID del usuario>​\r\nUNION​\r\nSELECT f.name AS folder_name, s.access_level_id​\r\nFROM Share s​\r\nJOIN FolderDMS f ON s.folder_id = f.folder_id​\r\nWHERE s.shared_with_user_id = <ID del usuario>;​\r\n\r\n■​ Para consultar la jerarquía de carpetas y documentos, se uniría la\r\n\r\ntabla de cierre con FolderDMS y DocumentDMS. Por ejemplo, para\r\nobtener toda la jerarquía de carpetas:​\r\nSQL​\r\nSELECT f.name AS descendant, p.name AS ancestor, fc.depth​\r\nFROM FolderClosure fc​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":539,"to":565}}}}],["56",{"pageContent":"tabla de cierre con FolderDMS y DocumentDMS. Por ejemplo, para\r\nobtener toda la jerarquía de carpetas:​\r\nSQL​\r\nSELECT f.name AS descendant, p.name AS ancestor, fc.depth​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.descendant_id = f.folder_id​\r\nJOIN FolderDMS p ON fc.ancestor_id = p.folder_id​\r\nORDER BY fc.depth;​\r\n\r\n■​ Para consultar los permisos efectivos para un usuario en un elemento\r\n\r\nespecífico, considerando la herencia, se consultaría la tabla de cierre\r\npara todos los ancestros del elemento y se uniría con las tablas de\r\npermisos:​\r\nSQL​\r\n\r\n\fSELECT al.name​\r\nFROM FolderClosure fc​\r\nJOIN FolderDMS f ON fc.ancestor_id = f.folder_id​\r\nJOIN EffectivePermission ep ON f.folder_id = ep.folder_id​\r\nJOIN AccessLevel al ON ep.access_level_id = al.access_level_id​\r\nWHERE fc.descendant_id = <ID del elemento>​\r\nAND ep.user_id = <ID del usuario>​\r\nORDER BY fc.depth;​\r\n\r\n○​ Creación de Registros:\r\n■​ Tabla de Cierre:","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":561,"to":587}}}}],["57",{"pageContent":"WHERE fc.descendant_id = <ID del elemento>​\r\nAND ep.user_id = <ID del usuario>​\r\nORDER BY fc.depth;​\r\n\r\n○​ Creación de Registros:\r\n■​ Tabla de Cierre:\r\n■​ Para crear un nuevo documento, se insertaría un registro en la tabla\r\n\r\nDocumentDMS con la información del documento.\r\n■​ Para crear una nueva carpeta, se insertaría un registro en la tabla\r\nFolderDMS con la información de la carpeta. Además, se deberían\r\ninsertar registros en la tabla de cierre (FolderClosure). Esto incluiría\r\nuna entrada auto-referencial (ancestor_id igual a descendant_id y\r\nprofundidad 0) y entradas para cada ancestro de la nueva carpeta. Si\r\nla nueva carpeta es hija de otra, se consultarían los ancestros de la\r\ncarpeta padre en la tabla de cierre y se insertarían nuevas filas para la\r\nnueva carpeta con esos ancestros y una profundidad incrementada en\r\n1. Por ejemplo, para insertar una nueva carpeta con ID new_folder_id\r\ncomo hija de una carpeta con ID parent_folder_id:​\r\nSQL​\r\n-- Insertar la nueva carpeta​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":582,"to":602}}}}],["58",{"pageContent":"1. Por ejemplo, para insertar una nueva carpeta con ID new_folder_id\r\ncomo hija de una carpeta con ID parent_folder_id:​\r\nSQL​\r\n-- Insertar la nueva carpeta​\r\nINSERT INTO FolderDMS (folder_id, parent_folder_id, name) VALUES\r\n\r\n(<new_folder_id>, <parent_folder_id>, '<nombre de la nueva carpeta>');​\r\n​\r\n-- Insertar la entrada auto-referencial en la tabla de cierre​\r\nINSERT INTO FolderClosure (ancestor_id, descendant_id, depth) VALUES\r\n(<new_folder_id>, <new_folder_id>, 0);​\r\n​\r\n-- Insertar entradas para los ancestros (incluyendo el padre)​\r\nINSERT INTO FolderClosure (ancestor_id, descendant_id, depth)​\r\nSELECT ancestor_id, <new_folder_id>, depth + 1​\r\nFROM FolderClosure​\r\nWHERE descendant_id = <parent_folder_id>;​\r\n■​ Para crear un nuevo permiso, se insertaría un registro en la tabla\r\n\r\nEffectivePermission con el ID del usuario, el ID del documento o\r\n\r\n\fcarpeta y el ID del nivel de acceso.\r\n6.​ Integración con Prisma ORM:\r\n○​ Definición de Modelos de Prisma:","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":599,"to":622}}}}],["59",{"pageContent":"EffectivePermission con el ID del usuario, el ID del documento o\r\n\r\n\fcarpeta y el ID del nivel de acceso.\r\n6.​ Integración con Prisma ORM:\r\n○​ Definición de Modelos de Prisma:\r\n■​ Para la estructura de base de datos con tabla de cierre, los modelos de\r\nPrisma correspondientes a las tablas DocumentDMS, FolderDMS,\r\nFolderClosure, EffectivePermission, Share y AccessLevel se definirían de\r\nla siguiente manera:​\r\nFragmento de código​\r\n\r\nmodel DocumentDMS {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nfolderId Int​\r\nname\r\nString​\r\nfolder FolderDMS @relation(fields: [folderId], references: [id])​\r\neffectivePermissions EffectivePermission​\r\nshares\r\nShare​\r\n}​\r\n​\r\nmodel FolderDMS {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nparentFolderId Int?​\r\nname\r\nString​\r\ndocuments\r\nDocumentDMS​\r\nparentFolder FolderDMS? @relation(\"FolderHierarchy\", fields:\r\n[parentFolderId], references: [id], onDelete: Cascade, onUpdate:\r\nCascade)​\r\nchildFolders FolderDMS @relation(\"FolderHierarchy\")​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":618,"to":654}}}}],["60",{"pageContent":"parentFolder FolderDMS? @relation(\"FolderHierarchy\", fields:\r\n[parentFolderId], references: [id], onDelete: Cascade, onUpdate:\r\nCascade)​\r\nchildFolders FolderDMS @relation(\"FolderHierarchy\")​\r\nancestorClosure FolderClosure @relation(\"Ancestor\")​\r\ndescendantClosure FolderClosure @relation(\"Descendant\")​\r\neffectivePermissions EffectivePermission​\r\nshares\r\nShare​\r\n}​\r\n​\r\nmodel FolderClosure {​\r\nancestorId Int​\r\ndescendantId Int​\r\ndepth\r\nInt​\r\nancestor FolderDMS @relation(\"Ancestor\", fields: [ancestorId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\ndescendant FolderDMS @relation(\"Descendant\", fields: [descendantId],\r\n\r\n\freferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n​\r\n@@id([ancestorId, descendantId])​\r\n}​\r\n​\r\nmodel EffectivePermission {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nuserId\r\nInt​\r\ndocumentId Int?​\r\nfolderId\r\nInt?​\r\naccessLevelId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":651,"to":688}}}}],["61",{"pageContent":"userId\r\nInt​\r\ndocumentId Int?​\r\nfolderId\r\nInt?​\r\naccessLevelId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\nfolder\r\nFolderDMS? @relation(fields: [folderId], references: [id],\r\nonDelete: Cascade, onUpdate: Cascade)​\r\naccessLevel AccessLevel @relation(fields: [accessLevelId], references:\r\n[id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel Share {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\ndocumentId\r\nInt?​\r\nfolderId\r\nInt?​\r\nsharedWithUserId Int​\r\naccessLevelId\r\nInt​\r\nsharedByUserId Int​\r\ndocument\r\nDocumentDMS? @relation(fields: [documentId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\nfolder\r\nFolderDMS? @relation(fields: [folderId], references: [id],\r\nonDelete: Cascade, onUpdate: Cascade)​\r\naccessLevel\r\nAccessLevel @relation(fields: [accessLevelId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel AccessLevel {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nname\r\nString​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":680,"to":724}}}}],["62",{"pageContent":"AccessLevel @relation(fields: [accessLevelId],\r\nreferences: [id], onDelete: Cascade, onUpdate: Cascade)​\r\n}​\r\n​\r\nmodel AccessLevel {​\r\nid\r\nInt\r\n@id @default(autoincrement())​\r\nname\r\nString​\r\npermissionsMask Int​\r\neffectivePermissions EffectivePermission​\r\n\r\n\fshares\r\n}​\r\n\r\nShare​\r\n\r\n○​ Uso del Cliente de Prisma para Consultas:\r\n■​ Para verificar los permisos de un usuario en una carpeta específica:​\r\nTypeScript​\r\nconst permissions = await prisma.folderClosure.findMany({​\r\nwhere: {​\r\ndescendantId: folderId,​\r\nancestor: {​\r\neffectivePermissions: {​\r\nsome: {​\r\nuserId: userId,​\r\nfolderId: { not: null },​\r\n\r\n},​\r\n},​\r\n},​\r\n},​\r\ninclude: {​\r\nancestor: {​\r\ninclude: {​\r\neffectivePermissions: {​\r\nwhere: { userId: userId },​\r\ninclude: { accessLevel: true },​\r\n\r\n},​\r\n},​\r\n},​\r\n},​\r\n});​\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\nusuario:​\r\nTypeScript​\r\nconst sharedItems = await prisma.share.findMany({​\r\nwhere: { sharedWithUserId: userId },​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":715,"to":765}}}}],["63",{"pageContent":"},​\r\n},​\r\n});​\r\n■​ Para obtener todos los documentos y carpetas compartidos con un\r\nusuario:​\r\nTypeScript​\r\nconst sharedItems = await prisma.share.findMany({​\r\nwhere: { sharedWithUserId: userId },​\r\ninclude: { document: true, folder: true, accessLevel: true },​\r\n\r\n});​\r\n■​ Para consultar la jerarquía de carpetas:​\r\n\r\n\fTypeScript​\r\nconst folderHierarchy = await prisma.folderClosure.findMany({​\r\ninclude: {​\r\nancestor: { select: { id: true, name: true } },​\r\ndescendant: { select: { id: true, name: true } },​\r\n\r\n},​\r\norderBy: { depth: 'asc' },​\r\n\r\n});​\r\n■​ Para obtener los permisos efectivos para un usuario en una carpeta\r\nespecífica (simplificado):​\r\nTypeScript​\r\nconst effectivePermissions = await prisma.effectivePermission.findMany({​\r\nwhere: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\n\r\n},​\r\ninclude: { accessLevel: true },​\r\n\r\n});​\r\n○​ Uso del Cliente de Prisma para Crear Registros:\r\n■​ Para crear una nueva carpeta:​\r\nTypeScript​\r\nconst newFolder = await prisma.folderDMS.create({​","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":758,"to":796}}}}],["64",{"pageContent":"},​\r\ninclude: { accessLevel: true },​\r\n\r\n});​\r\n○​ Uso del Cliente de Prisma para Crear Registros:\r\n■​ Para crear una nueva carpeta:​\r\nTypeScript​\r\nconst newFolder = await prisma.folderDMS.create({​\r\ndata: {​\r\nname: folderName,​\r\nparentFolderId: parentFolderId,​\r\nancestorClosure: {​\r\ncreate: [​\r\n\r\n{ ancestorId: newFolderId, depth: 0 }, // Auto-referencia​\r\n//... (Lógica para crear entradas de ancestros basada en el parentFolderId)​\r\n\r\n],​\r\n},​\r\n},​\r\n});​\r\n■​ Para crear un nuevo documento:​\r\nTypeScript​\r\nconst newDocument = await prisma.documentDMS.create({​\r\ndata: {​\r\n\r\n\fname: documentName,​\r\nfolderId: folderId,​\r\n\r\n},​\r\n});​\r\n■​ Para crear un nuevo permiso:​\r\nTypeScript​\r\nconst newPermission = await prisma.effectivePermission.create({​\r\ndata: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\naccessLevelId: accessLevelId,​\r\n\r\n},​\r\n});​\r\n7.​ Conclusión:​\r\n\r\nEl análisis presentado sugiere que la adopción del modelo de tabla de cierre para","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":789,"to":832}}}}],["65",{"pageContent":"data: {​\r\nuserId: userId,​\r\nfolderId: folderId,​\r\naccessLevelId: accessLevelId,​\r\n\r\n},​\r\n});​\r\n7.​ Conclusión:​\r\n\r\nEl análisis presentado sugiere que la adopción del modelo de tabla de cierre para\r\nla gestión de la jerarquía de carpetas y documentos ofrece ventajas significativas\r\nen términos de rendimiento de consultas para la gestión de permisos jerárquicos\r\ny la funcionalidad \"Compartido conmigo\". Si bien este modelo introduce una\r\nmayor complejidad en las operaciones de escritura, los beneficios en la eficiencia\r\nde las consultas, especialmente en sistemas con jerarquías profundas y un alto\r\nvolumen de comprobaciones de permisos, justifican el cambio de enfoque. Se\r\nrecomienda realizar pruebas de rendimiento exhaustivas con volúmenes de datos\r\ny patrones de consulta realistas para validar los beneficios esperados. También\r\nse deben considerar el impacto de la migración en los datos existentes y la curva\r\nde aprendizaje para el equipo con respecto al nuevo modelo.\r\nObras citadas","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":823,"to":843}}}}],["66",{"pageContent":"se deben considerar el impacto de la migración en los datos existentes y la curva\r\nde aprendizaje para el equipo con respecto al nuevo modelo.\r\nObras citadas\r\n1.​ Organize your files | Data management - MIT Libraries, fecha de acceso: abril 16,\r\n\r\n2025, https://libraries.mit.edu/data-management/store/organize/\r\n\r\n2.​ Directory Structure - Harvard Biomedical Data Management, fecha de acceso:\r\n\r\nabril 16, 2025,\r\nhttps://datamanagement.hms.harvard.edu/plan-design/directory-structure\r\n3.​ Designing a data file structure - CESSDA Data Management Expert Guide, fecha\r\nde acceso: abril 16, 2025,\r\nhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/Designing-a-data-file-structure\r\n4.​ File naming and folder structure - CESSDA Data Management Expert Guide,\r\nfecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/File-naming-and-folder-structure","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":841,"to":860}}}}],["67",{"pageContent":"fecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://dmeg.cessda.eu/Data-Management-Expert-Guide/2.-Organise-Documen\r\nt/File-naming-and-folder-structure\r\n5.​ File and Folder Organization - long draft - UC Merced Library, fecha de acceso:\r\nabril 16, 2025, https://library.ucmerced.edu/node/66751\r\n6.​ The Guide to Folder Structures - SuiteFiles, fecha de acceso: abril 16, 2025,\r\nhttps://www.suitefiles.com/guides/folder-structures-guide/\r\n7.​ Collaborative Document Management - Interfacing Technologies, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://interfacing.com/collaborative-document-management\r\n8.​ What is a Document Management System? - IRIS Software Group, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://www.irisglobal.com/blog/what-is-a-document-management-system/\r\n9.​ Understanding Permission Inheritance - Seeq Knowledge Base, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://support.seeq.com/kb/R64/cloud/understanding-permission-inheritance","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":857,"to":873}}}}],["68",{"pageContent":"9.​ Understanding Permission Inheritance - Seeq Knowledge Base, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://support.seeq.com/kb/R64/cloud/understanding-permission-inheritance\r\n10.​Hierarchical models in PostgreSQL | Ackee blog, fecha de acceso: abril 16, 2025,\r\nhttps://www.ackee.agency/blog/hierarchical-models-in-postgresql\r\n11.​ Closure Table | The Cache • Fueled Engineering, fecha de acceso: abril 16, 2025,\r\nhttps://fueled.com/the-cache/posts/backend/closure-table/\r\n12.​Database design for file sharing system like Google drive : r/AskProgramming Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/AskProgramming/comments/1g3msfs/database_design\r\n_for_file_sharing_system_like/\r\n13.​How to design a functionality to share content? - Software Engineering Stack\r\nExchange, fecha de acceso: abril 16, 2025,\r\nhttps://softwareengineering.stackexchange.com/questions/348606/how-to-desig\r\nn-a-functionality-to-share-content","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":871,"to":884}}}}],["69",{"pageContent":"Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://softwareengineering.stackexchange.com/questions/348606/how-to-desig\r\nn-a-functionality-to-share-content\r\n14.​SQL Server Closure Tables - Simple Talk - Redgate Software, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://www.red-gate.com/simple-talk/databases/sql-server/t-sql-programmingsql-server/sql-server-closure-tables/\r\n15.​Recursive CTE vs closure table for storing hierarchical information : r/PostgreSQL\r\n- Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/PostgreSQL/comments/1777s0t/recursive_cte_vs_closu\r\nre_table_for_storing/\r\n16.​Transitive Closure in PostgreSQL - Remind Engineering, fecha de acceso: abril 16,\r\n2025, https://engineering.remind.com/Transitive-Closure-In-PostgreSQL/\r\n17.​franzose/ClosureTable: Adjacency List'ed Closure Table database design pattern\r\nimplementation for the Laravel framework. - GitHub, fecha de acceso: abril 16,\r\n2025, https://github.com/franzose/ClosureTable","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":882,"to":896}}}}],["70",{"pageContent":"implementation for the Laravel framework. - GitHub, fecha de acceso: abril 16,\r\n2025, https://github.com/franzose/ClosureTable\r\n18.​This is a mysql and postgresql store procedure and trigger implementation of\r\nclosure table in RDBMS about hierarchy data model. - GitHub, fecha de acceso:\r\nabril 16, 2025, https://github.com/developerworks/hierarchy-data-closure-table\r\n19.​The relational modeling of hierarchical data in biodiversity databases - Oxford\r\nAcademic, fecha de acceso: abril 16, 2025,\r\n\r\n\fhttps://academic.oup.com/database/article/doi/10.1093/database/baae107/781784\r\n3\r\n20.​Store Hierarchical Data Seamlessly | PostgreSQL - Closure Table, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://technobytz.com/closure_table_store_hierarchical_data.html\r\n21.​WillSoss/closure-tree: A closure table implementation in C#/MSSQL. - GitHub,\r\nfecha de acceso: abril 16, 2025, https://github.com/WillSoss/closure-tree\r\n22.​Choice of Database schema for storing folder system - Stack Overflow, fecha de","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":895,"to":910}}}}],["71",{"pageContent":"fecha de acceso: abril 16, 2025, https://github.com/WillSoss/closure-tree\r\n22.​Choice of Database schema for storing folder system - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/13104601/choice-of-database-schema-forstoring-folder-system\r\n23.​Moving Subtrees in Closure Table Hierarchies - Percona, fecha de acceso: abril 16,\r\n2025, https://www.percona.com/blog/moving-subtrees-in-closure-table/\r\n24.​The simplest(?) way to do tree-based queries in SQL - dirtSimple.org, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://dirtsimple.org/2010/11/simplest-way-to-do-tree-based-queries.html\r\n25.​How can I create a closure table using data from an adjacency list? - Stack\r\nOverflow, fecha de acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/12621873/how-can-i-create-a-closure-table\r\n-using-data-from-an-adjacency-list\r\n26.​Rendering Trees with Closure Tables – Keeping It Simple - Karwin, fecha de\r\nacceso: abril 16, 2025,","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":909,"to":923}}}}],["72",{"pageContent":"-using-data-from-an-adjacency-list\r\n26.​Rendering Trees with Closure Tables – Keeping It Simple - Karwin, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://karwin.com/blog/index.php/2010/03/24/rendering-trees-with-closure-tabl\r\nes/\r\n27.​Hierarchical Structures in PostgreSQL (2020) - Hacker News, fecha de acceso:\r\nabril 16, 2025, https://news.ycombinator.com/item?id=27631765\r\n28.​Working with Graphs in Postgres Part 2: Extending the Closure Table Pattern to\r\nSupport DAGs - Lucas Nagle, fecha de acceso: abril 16, 2025,\r\nhttps://lnagle.github.io/extended-closure-table-pattern.html\r\n29.​data modeling - Managing hierarchies in SQL: MPTT/nested sets vs ..., fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/8196175/managing-hierarchies-in-sql-mpttnested-sets-vs-adjacency-lists-vs-storing-path\r\n30.​Moving in Closure Table with Multiple Parents - sql - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":921,"to":935}}}}],["73",{"pageContent":"30.​Moving in Closure Table with Multiple Parents - sql - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/9641932/moving-in-closure-table-with-multi\r\nple-parents\r\n31.​Hierarchical data using closure table, how to ensure that a column is unique within\r\nthe parent node? - DBA Stack Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/269404/hierarchical-data-using-closur\r\ne-table-how-to-ensure-that-a-column-is-unique-wit\r\n32.​Implementing version history with a closure table schema - Stack Overflow, fecha\r\nde acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/13457479/implementing-version-history-wit\r\nh-a-closure-table-schema\r\n\r\n\f33.​Worked example of closure tables with from and thru dates - DBA Stack\r\n\r\nExchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/230966/worked-example-of-closure-t\r\nables-with-from-and-thru-dates","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":934,"to":951}}}}],["74",{"pageContent":"Exchange, fecha de acceso: abril 16, 2025,\r\nhttps://dba.stackexchange.com/questions/230966/worked-example-of-closure-t\r\nables-with-from-and-thru-dates\r\n34.​Use closure tables to implement file cache without full path column · Issue #4209\r\n· owncloud/core - GitHub, fecha de acceso: abril 16, 2025,\r\nhttps://github.com/owncloud/core/issues/4209\r\n35.​When inserting why does a closure table point to itself - Stack Overflow, fecha de\r\nacceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/22416571/when-inserting-why-does-a-closu\r\nre-table-point-to-itself\r\n36.​hierarchical data in a database: recursive query vs. closure tables vs. graph\r\ndatabase, fecha de acceso: abril 16, 2025,\r\nhttps://stackoverflow.com/questions/7497812/hierarchical-data-in-a-database-re\r\ncursive-query-vs-closure-tables-vs-graph-da\r\n37.​How to Store and Query Categories : r/PHP - Reddit, fecha de acceso: abril 16,\r\n2025,\r\nhttps://www.reddit.com/r/PHP/comments/l72ve8/how_to_store_and_query_categ\r\nories/","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":949,"to":966}}}}],["75",{"pageContent":"37.​How to Store and Query Categories : r/PHP - Reddit, fecha de acceso: abril 16,\r\n2025,\r\nhttps://www.reddit.com/r/PHP/comments/l72ve8/how_to_store_and_query_categ\r\nories/\r\n38.​How would you model a file tree? : r/SQL - Reddit, fecha de acceso: abril 16, 2025,\r\nhttps://www.reddit.com/r/SQL/comments/rt3d9a/how_would_you_model_a_file_tr\r\nee/\r\n39.​Nested Sets vs Closure Table in real life apps : r/PHP - Reddit, fecha de acceso:\r\nabril 16, 2025,\r\nhttps://www.reddit.com/r/PHP/comments/3mgomv/nested_sets_vs_closure_table_\r\nin_real_life_apps/\r\n\r\n\f\r\n\r\nEste analisis fue realizado por Aaron Santander","metadata":{"source":"docs\\analisis_prisma_permisos_dms.txt","loc":{"lines":{"from":963,"to":977}}}}]]